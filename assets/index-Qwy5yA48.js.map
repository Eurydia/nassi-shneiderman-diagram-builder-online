{"version":3,"file":"index-Qwy5yA48.js","sources":["../../src/interpreter/lexer.ts","../../src/interpreter/parser.ts","../../src/App/components/Diagram/ArrowTopLeftBottomRight.tsx","../../src/App/components/Diagram/ArrowBottomLeftTopRight.tsx","../../src/App/components/Diagram/Diagram.tsx","../../src/App/components/DiagramPreview.tsx","../../src/App/components/StyledCodeEditor/StyledCodeEditor.tsx","../../src/App/components/AdaptiveButton.tsx","../../src/App/components/LiveEditor/LiveEditor.tsx","../../src/App/components/LiveEditor/useExportDiagram.ts","../../src/App/components/LiveEditor/useEditorContent.ts","../../src/App/components/LiveEditor/helper.ts","../../src/App/App.tsx","../../src/main.tsx"],"sourcesContent":["export enum DiagramTokenKind {\r\n\tEOF = 0,\r\n\tSYMBOL,\r\n\tKEYWORD,\r\n\r\n\tLEFT_PAREN,\r\n\tRIGHT_PAREN,\r\n\tLEFT_CURLY,\r\n\tRIGHT_CURLY,\r\n\tSEMICOLON,\r\n\tWHITE_SPACE,\r\n}\r\n\r\nexport type DiagramToken = {\r\n\tkind: DiagramTokenKind;\r\n\ttext: string;\r\n\tlineNumber: number;\r\n\tcharNumber: number;\r\n};\r\n\r\nconst KEYWORDS: string[] = [\r\n\t\"for\",\r\n\t\"if\",\r\n\t\"else\",\r\n\t\"while\",\r\n\t\"do\",\r\n];\r\n\r\nconst LITERAL_TOKENS: Record<\r\n\tstring,\r\n\tDiagramTokenKind\r\n> = {\r\n\t\"{\": DiagramTokenKind.LEFT_CURLY,\r\n\t\"}\": DiagramTokenKind.RIGHT_CURLY,\r\n\t\"(\": DiagramTokenKind.LEFT_PAREN,\r\n\t\")\": DiagramTokenKind.RIGHT_PAREN,\r\n\t\";\": DiagramTokenKind.SEMICOLON,\r\n};\r\n\r\nexport type Lexer = {\r\n\tcontent: string;\r\n\tcontentLength: number;\r\n\tcursorPos: number;\r\n\r\n\tcursorRow: number;\r\n\tcursorCol: number;\r\n};\r\n\r\nconst removeComments = (\r\n\tcontent: string,\r\n): string => {\r\n\tlet cleanContent = \"\";\r\n\r\n\tlet contentPos = 0;\r\n\twhile (contentPos < content.length) {\r\n\t\tif (\r\n\t\t\tcontentPos + 1 < content.length &&\r\n\t\t\tcontent[contentPos] === \"/\" &&\r\n\t\t\tcontent[contentPos + 1] === \"/\"\r\n\t\t) {\r\n\t\t\twhile (\r\n\t\t\t\tcontentPos < content.length &&\r\n\t\t\t\tcontent[contentPos] !== \"\\n\"\r\n\t\t\t) {\r\n\t\t\t\tcontentPos++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcleanContent += content[contentPos];\r\n\t\tcontentPos++;\r\n\t}\r\n\r\n\treturn cleanContent;\r\n};\r\n\r\nexport const lexerInit = (\r\n\tcontent: string,\r\n): Lexer => {\r\n\tconst cleanedContent = removeComments(\r\n\t\tcontent.normalize(),\r\n\t);\r\n\r\n\treturn {\r\n\t\tcontent: cleanedContent,\r\n\t\tcontentLength: cleanedContent.length,\r\n\t\tcursorPos: 0,\r\n\t\tcursorCol: 1,\r\n\t\tcursorRow: 1,\r\n\t};\r\n};\r\n\r\nexport const lexerGetNextTokenThenAdvance = (\r\n\tl: Lexer,\r\n): DiagramToken => {\r\n\tconst token: DiagramToken = {\r\n\t\tkind: DiagramTokenKind.EOF,\r\n\t\ttext: \"\",\r\n\t\tlineNumber: l.cursorRow,\r\n\t\tcharNumber: l.cursorCol,\r\n\t};\r\n\r\n\tif (l.cursorPos >= l.contentLength) {\r\n\t\treturn token;\r\n\t}\r\n\r\n\ttoken[\"text\"] = l.content[l.cursorPos];\r\n\tl.cursorPos++;\r\n\tl.cursorCol++;\r\n\r\n\tif (/\\s/.test(token.text)) {\r\n\t\ttoken.kind = DiagramTokenKind.WHITE_SPACE;\r\n\t\tif (token.text === \"\\n\") {\r\n\t\t\tl.cursorRow++;\r\n\t\t\tl.cursorCol = 1;\r\n\t\t}\r\n\t\treturn token;\r\n\t}\r\n\r\n\tif (token[\"text\"] in LITERAL_TOKENS) {\r\n\t\ttoken[\"kind\"] = LITERAL_TOKENS[token[\"text\"]];\r\n\t\treturn token;\r\n\t}\r\n\r\n\twhile (\r\n\t\tl[\"cursorPos\"] < l.contentLength &&\r\n\t\t!(l.content[l.cursorPos] in LITERAL_TOKENS) &&\r\n\t\t!/\\s/.test(l.content[l.cursorPos])\r\n\t) {\r\n\t\ttoken[\"text\"] += l.content[l.cursorPos];\r\n\t\tl.cursorPos++;\r\n\t\tl.cursorCol++;\r\n\t}\r\n\r\n\tif (KEYWORDS.includes(token.text)) {\r\n\t\ttoken.kind = DiagramTokenKind.KEYWORD;\r\n\t\treturn token;\r\n\t}\r\n\r\n\ttoken.kind = DiagramTokenKind.SYMBOL;\r\n\treturn token;\r\n};\r\n\r\nexport const lexerGetAllTokens = (\r\n\tl: Lexer,\r\n): DiagramToken[] => {\r\n\tconst tokens: DiagramToken[] = [];\r\n\tlet token: DiagramToken;\r\n\twhile (\r\n\t\t(token = lexerGetNextTokenThenAdvance(l))\r\n\t\t\t.kind !== DiagramTokenKind.EOF\r\n\t) {\r\n\t\ttokens.push(token);\r\n\t}\r\n\treturn tokens;\r\n};\r\n","import {\r\n\tDiagramToken,\r\n\tDiagramTokenKind,\r\n} from \"./lexer\";\r\n\r\nexport enum DiagramNodeKind {\r\n\tEOF = 0,\r\n\tERROR,\r\n\tPROCESS,\r\n\tLOOP_FIRST,\r\n\tLOOP_LAST,\r\n\tIF_ELSE,\r\n\tFUNCTION,\r\n}\r\n\r\ntype DiagramNodeEOF = {\r\n\tkind: DiagramNodeKind.EOF;\r\n};\r\n\r\ntype DiagramNodeError = {\r\n\tkind: DiagramNodeKind.ERROR;\r\n\tcaretOffset: number;\r\n\tlineNumber: number;\r\n\tcharNumber: number;\r\n\tcontext: string;\r\n\treason: string;\r\n};\r\n\r\ntype DiagramNodeProcess = {\r\n\tkind: DiagramNodeKind.PROCESS;\r\n\tbody: DiagramToken[];\r\n};\r\n\r\ntype DiagramNodeLoopFirst = {\r\n\tkind: DiagramNodeKind.LOOP_FIRST;\r\n\tcondition: DiagramToken[];\r\n\tbody: Node[];\r\n};\r\n\r\ntype DiagramNodeLoopLast = {\r\n\tkind: DiagramNodeKind.LOOP_LAST;\r\n\tcondition: DiagramToken[];\r\n\tbody: Node[];\r\n};\r\n\r\ntype DiagramNodeIfElse = {\r\n\tkind: DiagramNodeKind.IF_ELSE;\r\n\tcondition: DiagramToken[];\r\n\tbodyIf: Node[];\r\n\tbodyElse: Node[];\r\n};\r\n\r\ntype DiagramNodeFunction = {\r\n\tkind: DiagramNodeKind.FUNCTION;\r\n\tdeclaration: DiagramToken[];\r\n\tbody: Node[];\r\n};\r\n\r\nexport type Node =\r\n\t| DiagramNodeEOF\r\n\t| DiagramNodeProcess\r\n\t| DiagramNodeLoopFirst\r\n\t| DiagramNodeLoopLast\r\n\t| DiagramNodeIfElse\r\n\t| DiagramNodeFunction\r\n\t| DiagramNodeEOF\r\n\t| DiagramNodeError;\r\n\r\nexport type Parser = {\r\n\ttokens: DiagramToken[];\r\n\ttokenLength: number;\r\n\tcursorPos: number;\r\n};\r\n\r\nexport const parserInit = (\r\n\ttokens: DiagramToken[],\r\n): Parser => {\r\n\treturn {\r\n\t\ttokens: tokens,\r\n\t\ttokenLength: tokens.length,\r\n\t\tcursorPos: 0,\r\n\t};\r\n};\r\n\r\nconst parserCollectTokensBetween = (\r\n\tp: Parser,\r\n\tstartToken: DiagramTokenKind,\r\n\tstopToken: DiagramTokenKind,\r\n): DiagramToken[] => {\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn [];\r\n\t}\r\n\tif (p.tokens[p.cursorPos].kind !== startToken) {\r\n\t\treturn [];\r\n\t}\r\n\t// Consume the start token\r\n\tp.cursorPos++;\r\n\r\n\t// Does not include the start but includes the stop token\r\n\tconst tokens: DiagramToken[] = [];\r\n\r\n\tlet depth = -1;\r\n\tlet token: DiagramToken;\r\n\twhile (p.cursorPos < p.tokenLength) {\r\n\t\ttoken = p.tokens[p.cursorPos];\r\n\t\tp.cursorPos++;\r\n\t\tif (token.kind === startToken) {\r\n\t\t\tdepth--;\r\n\t\t}\r\n\t\tif (token.kind === stopToken) {\r\n\t\t\tdepth++;\r\n\t\t}\r\n\t\ttokens.push(token);\r\n\r\n\t\tif (depth === 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t// The cursor is pointing the token immediately after\r\n\t// the stop token\r\n\treturn tokens;\r\n};\r\n\r\nconst parserSkipWhiteSpace = (\r\n\tp: Parser,\r\n): void => {\r\n\twhile (\r\n\t\tp.cursorPos < p.tokenLength &&\r\n\t\tp.tokens[p.cursorPos].kind ===\r\n\t\t\tDiagramTokenKind.WHITE_SPACE\r\n\t) {\r\n\t\tp.cursorPos++;\r\n\t}\r\n};\r\n\r\nconst parserBuildLoopFirstNode = (\r\n\tp: Parser,\r\n): DiagramNodeLoopFirst | DiagramNodeError => {\r\n\tconst node: DiagramNodeLoopFirst = {\r\n\t\tkind: DiagramNodeKind.LOOP_FIRST,\r\n\t\tbody: [],\r\n\t\tcondition: [],\r\n\t};\r\n\r\n\t// Set \"for\" token as marker\r\n\tlet markerToken: DiagramToken =\r\n\t\tp.tokens[p.cursorPos - 1];\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"(\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-first loop declaration. Missing a \"(\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"(\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_PAREN\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in test-first loop declaration. Expected a \"(\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"(\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tnode.condition = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_PAREN,\r\n\t\tDiagramTokenKind.RIGHT_PAREN,\r\n\t);\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"(\" token as marker\r\n\tif (node.condition.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tnode.condition[node.condition.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \")\" token is missing\r\n\t// Or the condition is not empty but \")\" is not found\r\n\tif (\r\n\t\tnode.condition.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_PAREN\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-first loop declaration. Missing a \")\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume \")\" token from condition\r\n\tnode.condition.pop();\r\n\t// By this point, \")\" token is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-first loop declaration. Missing a \"{\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in test-first loop declaration. Expected a \"{\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\r\n\t// If body has at least one token,\r\n\t// set the last token as marker .\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyTokens[bodyTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-first loop declaration. Missing a \"}\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume \"}\" token from body\r\n\tbodyTokens.pop();\r\n\r\n\tnode.body = parserGetAllNodes(\r\n\t\tparserInit(bodyTokens),\r\n\t);\r\n\treturn node;\r\n};\r\n\r\nconst parserBuildLoopLastNode = (\r\n\tp: Parser,\r\n): DiagramNodeLoopLast | DiagramNodeError => {\r\n\tconst node: DiagramNodeLoopLast = {\r\n\t\tkind: DiagramNodeKind.LOOP_LAST,\r\n\t\tbody: [],\r\n\t\tcondition: [],\r\n\t};\r\n\r\n\t// Set \"do\" token as marker\r\n\tlet markerToken = p.tokens[p.cursorPos - 1];\r\n\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-last loop declaration. Missing a \"{\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in test-last loop declaration. Expected a \"{\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\r\n\t// If body has at least one token,\r\n\t// set the last token as marker and consume it.\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyTokens[bodyTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-last loop declaration. Missing \"}\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume the \"}\" token in body\r\n\tbodyTokens.pop();\r\n\t// By this point, the marker is \"}\" token\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"while\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-last loop declaration. Missing a \"while\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found after \"}\" is not a \"while\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.KEYWORD ||\r\n\t\tp.tokens[p.cursorPos].text !== \"while\"\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in test-last loop declaration. Expected a \"while\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"while\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\t// Consume \"while token\"\r\n\tp.cursorPos++;\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"(\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-last loop declaration. Missing a \"(\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"(\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_PAREN\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in test-last loop declaration. Expected a \"(\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"(\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tnode.condition = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_PAREN,\r\n\t\tDiagramTokenKind.RIGHT_PAREN,\r\n\t);\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"(\" token as marker\r\n\tif (node.condition.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tnode.condition[node.condition.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \")\" token is missing\r\n\t// Or the condition is not empty but \")\" is not found\r\n\tif (\r\n\t\tnode.condition.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_PAREN\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-last loop declaration. Missing a \")\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume \")\" token from condition\r\n\tnode.condition.pop();\r\n\t// At this point, \")\" is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \";\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete test-last loop declaration. Missing a \";\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found after \")\" is not a \";\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.SEMICOLON\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in test-last loop declaration. Expected a \";\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume semicolon token\r\n\tp.cursorPos++;\r\n\r\n\t// Only build the body nodes if the parent declaration is correct\r\n\tnode.body = parserGetAllNodes(\r\n\t\tparserInit(bodyTokens),\r\n\t);\r\n\treturn node;\r\n};\r\n\r\nconst parserBuildIfElseNode = (\r\n\tp: Parser,\r\n): DiagramNodeIfElse | DiagramNodeError => {\r\n\tconst node: DiagramNodeIfElse = {\r\n\t\tkind: DiagramNodeKind.IF_ELSE,\r\n\t\tcondition: [],\r\n\t\tbodyIf: [],\r\n\t\tbodyElse: [],\r\n\t};\r\n\t// Set \"for\" token as marker\r\n\tlet markerToken: DiagramToken =\r\n\t\tp.tokens[p.cursorPos - 1];\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"(\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete branching block (if) declaration. Missing a \"(\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"(\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_PAREN\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in branching block (if) declaration. Expected a \"(\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"(\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\tnode.condition = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_PAREN,\r\n\t\tDiagramTokenKind.RIGHT_PAREN,\r\n\t);\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"(\" token as marker\r\n\tif (node.condition.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tnode.condition[node.condition.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \")\" token is missing\r\n\t// Or the condition is not empty but \")\" is not found\r\n\tif (\r\n\t\tnode.condition.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_PAREN\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete branching block (if) declaration. Missing a \")\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume \")\" token from condition\r\n\tnode.condition.pop();\r\n\t// By this point, \")\" token is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete branching block (if) declaration. Missing a \"{\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in branching block (if) declaration. Expected a \"{\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyIfTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\t// If body has at least one token,\r\n\t// set the last token as marker .\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyIfTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyIfTokens[bodyIfTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyIfTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete branching block (if) declaration. Missing a \"}\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume \"}\" token from body\r\n\tbodyIfTokens.pop();\r\n\t// Only parse the body after the declaration is valid\r\n\t// the body of if branch has to be parsed here\r\n\t// before possible return\r\n\tnode.bodyIf = parserGetAllNodes(\r\n\t\tparserInit(bodyIfTokens),\r\n\t);\r\n\tparserSkipWhiteSpace(p);\r\n\t// The branching block is complete\r\n\t// No need for error at this point\r\n\tif (\r\n\t\tp.cursorPos >= p.tokenLength ||\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.KEYWORD ||\r\n\t\tp.tokens[p.cursorPos].text !== \"else\"\r\n\t) {\r\n\t\treturn node;\r\n\t}\r\n\t// The cursor is pointing at \"else\" token\r\n\t// Set \"else\" as marker and consume it\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\tp.cursorPos++;\r\n\t// By this point, \"else\" is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete branching block (if-else) declaration. Missing a \"{\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\tconst { text: markerTokenText } = markerToken;\r\n\t\tconst {\r\n\t\t\ttext: errorTokenText,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t} = p.tokens[p.cursorPos];\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Unexpected token found in branching block (if-else) declaration. Expected a \"{\" token but found \"${errorTokenText}\" instead.`,\r\n\t\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyElseTokens =\r\n\t\tparserCollectTokensBetween(\r\n\t\t\tp,\r\n\t\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t\t);\r\n\t// If body has at least one token,\r\n\t// set the last token as marker .\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyElseTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyElseTokens[bodyElseTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyElseTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete branching block (if-else) declaration. Missing a \"}\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\t// Consume \"}\" token from body\r\n\tbodyElseTokens.pop();\r\n\r\n\tnode.bodyElse = parserGetAllNodes(\r\n\t\tparserInit(bodyElseTokens),\r\n\t);\r\n\r\n\treturn node;\r\n};\r\n\r\nconst parserGetNextNodeThenAdvance = (\r\n\tp: Parser,\r\n): Node => {\r\n\tparserSkipWhiteSpace(p);\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.EOF,\r\n\t\t};\r\n\t}\r\n\tconst token = p.tokens[p.cursorPos];\r\n\tp.cursorPos++;\r\n\tif (token.kind === DiagramTokenKind.KEYWORD) {\r\n\t\tswitch (token.text) {\r\n\t\t\tcase \"for\":\r\n\t\t\tcase \"while\":\r\n\t\t\t\treturn parserBuildLoopFirstNode(p);\r\n\t\t\tcase \"do\":\r\n\t\t\t\treturn parserBuildLoopLastNode(p);\r\n\t\t\tcase \"if\":\r\n\t\t\t\treturn parserBuildIfElseNode(p);\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tconst tokens: DiagramToken[] = [token];\r\n\tlet markerToken = token;\r\n\r\n\tif (\r\n\t\tmarkerToken.kind ===\r\n\t\tDiagramTokenKind.SEMICOLON\r\n\t) {\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.PROCESS,\r\n\t\t\tbody: [],\r\n\t\t};\r\n\t}\r\n\r\n\t// Consume tokens until \";\" or \"{\" token is found\r\n\twhile (\r\n\t\tp.cursorPos < p.tokenLength &&\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.SEMICOLON &&\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\tmarkerToken = p.tokens[p.cursorPos];\r\n\t\ttokens.push(p.tokens[p.cursorPos]);\r\n\t\tp.cursorPos++;\r\n\t}\r\n\r\n\t// Neither \";\" or \"{\" token is found\r\n\t// The loop terminates becaues EOF\r\n\t// Also assumed that the use ris trying to write a process\r\n\t// instead of a function\r\n\tif (\r\n\t\tp.cursorPos >= p.tokenLength ||\r\n\t\t(p.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.LEFT_CURLY &&\r\n\t\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\t\tDiagramTokenKind.SEMICOLON)\r\n\t) {\r\n\t\tconst { text, lineNumber, charNumber } =\r\n\t\t\tmarkerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete process declaration. Missing a \";\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length,\r\n\t\t\tlineNumber,\r\n\t\t\tcharNumber,\r\n\t\t};\r\n\t}\r\n\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind ===\r\n\t\tDiagramTokenKind.SEMICOLON\r\n\t) {\r\n\t\tp.cursorPos++;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.PROCESS,\r\n\t\t\tbody: tokens,\r\n\t\t};\r\n\t}\r\n\r\n\t// It is confirmed that the loop stopped\r\n\t// because it encountered a \"{\" token\r\n\t// Set it as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"{\" token as marker\r\n\tif (bodyTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyTokens[bodyTokens.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \"}\" token is missing\r\n\t// Or the condition is not empty but \"}\" is not found\r\n\tif (\r\n\t\tbodyTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\tconst {\r\n\t\t\ttext,\r\n\t\t\tlineNumber: rowPos,\r\n\t\t\tcharNumber: colPos,\r\n\t\t} = markerToken;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.ERROR,\r\n\t\t\treason: `Incomplete function declaration. Missing a \"}\" token.`,\r\n\t\t\tcontext: text,\r\n\t\t\tcaretOffset: text.length + 1,\r\n\t\t\tlineNumber: rowPos,\r\n\t\t\tcharNumber: colPos,\r\n\t\t};\r\n\t}\r\n\t// Consume the \"}\" token from body\r\n\tbodyTokens.pop();\r\n\r\n\treturn {\r\n\t\tkind: DiagramNodeKind.FUNCTION,\r\n\t\tdeclaration: tokens,\r\n\t\tbody: parserGetAllNodes(\r\n\t\t\tparserInit(bodyTokens),\r\n\t\t),\r\n\t};\r\n};\r\n\r\nexport const parserGetAllNodes = (\r\n\tp: Parser,\r\n): Node[] => {\r\n\tconst nodes: Node[] = [];\r\n\tlet node: Node;\r\n\twhile (\r\n\t\t(node = parserGetNextNodeThenAdvance(p))\r\n\t\t\t.kind !== DiagramNodeKind.EOF\r\n\t) {\r\n\t\tnodes.push(node);\r\n\t\tif (node.kind === DiagramNodeKind.ERROR) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn nodes;\r\n};\r\n","import { FC } from \"react\";\r\nimport {\r\n\tSvgIconProps,\r\n\tSvgIcon,\r\n} from \"@mui/material\";\r\n\r\nexport const ArrowTopLeftBottomRight: FC<\r\n\tSvgIconProps\r\n> = (props) => {\r\n\tconst { sx } = props;\r\n\r\n\treturn (\r\n\t\t<SvgIcon\r\n\t\t\tsx={{\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\twidth: \"100%\",\r\n\t\t\t\theight: \"100%\",\r\n\t\t\t\t...sx,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t<svg\r\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\tpreserveAspectRatio=\"none\"\r\n\t\t\t\tfill=\"none\"\r\n\t\t\t\tviewBox=\"0 0 5 5\"\r\n\t\t\t\tstrokeWidth=\"0.1\"\r\n\t\t\t>\r\n\t\t\t\t<line\r\n\t\t\t\t\tx1=\"0\"\r\n\t\t\t\t\ty1=\"0\"\r\n\t\t\t\t\tx2=\"5\"\r\n\t\t\t\t\ty2=\"5\"\r\n\t\t\t\t\tstroke=\"currentColor\"\r\n\t\t\t\t\tstrokeLinecap=\"round\"\r\n\t\t\t\t/>\r\n\t\t\t</svg>\r\n\t\t</SvgIcon>\r\n\t);\r\n};\r\n","import { FC } from \"react\";\r\nimport {\r\n\tSvgIconProps,\r\n\tSvgIcon,\r\n} from \"@mui/material\";\r\n\r\nexport const ArrowBottomLeftTopRight: FC<\r\n\tSvgIconProps\r\n> = (props) => {\r\n\tconst { sx } = props;\r\n\r\n\treturn (\r\n\t\t<SvgIcon\r\n\t\t\tsx={{\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\twidth: \"100%\",\r\n\t\t\t\theight: \"100%\",\r\n\t\t\t\t...sx,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t<svg\r\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\tpreserveAspectRatio=\"none\"\r\n\t\t\t\tfill=\"none\"\r\n\t\t\t\tviewBox=\"0 0 5 5\"\r\n\t\t\t\tstrokeWidth=\"0.1\"\r\n\t\t\t>\r\n\t\t\t\t<line\r\n\t\t\t\t\tx1=\"0\"\r\n\t\t\t\t\ty1=\"5\"\r\n\t\t\t\t\tx2=\"5\"\r\n\t\t\t\t\ty2=\"0\"\r\n\t\t\t\t\tstroke=\"currentColor\"\r\n\t\t\t\t\tstrokeLinecap=\"round\"\r\n\t\t\t\t/>\r\n\t\t\t</svg>\r\n\t\t</SvgIcon>\r\n\t);\r\n};\r\n","import { FC, Fragment, ReactNode } from \"react\";\r\nimport {\r\n\tBox,\r\n\tGrid,\r\n\tTypographyProps,\r\n\tTypography,\r\n\tStack,\r\n} from \"@mui/material\";\r\nimport { grey } from \"@mui/material/colors\";\r\n\r\nimport { ArrowTopLeftBottomRight } from \"./ArrowTopLeftBottomRight\";\r\nimport { ArrowBottomLeftTopRight } from \"./ArrowBottomLeftTopRight\";\r\nimport {\r\n\tNode,\r\n\tDiagramNodeKind,\r\n\tDiagramToken,\r\n} from \"interpreter\";\r\n\r\ntype DiagramWrapperProps = {\r\n\tchildren: ReactNode | ReactNode[];\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramWrapper: FC<DiagramWrapperProps> = (\r\n\tprops,\r\n) => {\r\n\tconst {\r\n\t\tchildren,\r\n\t\tborderTop,\r\n\t\tborderBottom,\r\n\t\tborderLeft,\r\n\t\tborderRight,\r\n\t} = props;\r\n\treturn (\r\n\t\t<Box\r\n\t\t\tsx={{\r\n\t\t\t\tborderStyle: \"solid\",\r\n\t\t\t\tborderLeftWidth: borderLeft ? 2 : 0,\r\n\t\t\t\tborderTopWidth: borderTop ? 2 : 0,\r\n\t\t\t\tborderBottomWidth: borderBottom ? 2 : 0,\r\n\t\t\t\tborderRightWidth: borderRight ? 2 : 0,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{children}\r\n\t\t</Box>\r\n\t);\r\n};\r\n\r\ntype DiagramComponentTextProps =\r\n\tTypographyProps & {\r\n\t\tchildren?: string;\r\n\t};\r\nconst DiagramComponentText: FC<\r\n\tDiagramComponentTextProps\r\n> = (props) => {\r\n\tconst { children, ...rest } = props;\r\n\r\n\treturn (\r\n\t\t<Typography\r\n\t\t\tpadding={1.5}\r\n\t\t\t{...rest}\r\n\t\t\tsx={{\r\n\t\t\t\tfontFamily: \"Fira Code\",\r\n\t\t\t\twordBreak: \"break-word\",\r\n\t\t\t\tfontVariantLigatures: \"contextual\",\r\n\t\t\t\t...rest.sx,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{children ?? \"-\"}\r\n\t\t</Typography>\r\n\t);\r\n};\r\n\r\ntype DiagramProcessProps = {\r\n\tbodyTokens?: DiagramToken[];\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramProcess: FC<DiagramProcessProps> = (\r\n\tprops,\r\n) => {\r\n\tconst { bodyTokens, ...rest } = props;\r\n\r\n\tlet bodyText: string | undefined = undefined;\r\n\tif (bodyTokens !== undefined) {\r\n\t\tbodyText = bodyTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t\tif (bodyText.length === 0) {\r\n\t\t\tbodyText = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{bodyText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramLoopFirstProps = {\r\n\tconditionTokens?: DiagramToken[];\r\n\tbody: Node[];\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const DiagramLoopFirst: FC<\r\n\tDiagramLoopFirstProps\r\n> = (props) => {\r\n\tconst { conditionTokens, body, ...rest } =\r\n\t\tprops;\r\n\r\n\tlet conditionText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tconditionTokens !== undefined &&\r\n\t\tconditionTokens.length > 0\r\n\t) {\r\n\t\tconditionText = conditionTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNode: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess\r\n\t\t\tborderTop\r\n\t\t\tborderLeft\r\n\t\t/>\r\n\t);\r\n\tif (body.length > 0) {\r\n\t\tbodyNode = body.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`subnode-${index}`}\r\n\t\t\t\tborderTop\r\n\t\t\t\tborderLeft\r\n\t\t\t\tnode={subnode}\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{conditionText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<Box paddingLeft={2}>{bodyNode}</Box>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramLoopLastProps = {\r\n\tconditionTokens?: DiagramToken[];\r\n\tbody: Node[];\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const DiagramLoopLast: FC<\r\n\tDiagramLoopLastProps\r\n> = (props) => {\r\n\tconst { conditionTokens, body, ...rest } =\r\n\t\tprops;\r\n\r\n\tlet conditionText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tconditionTokens !== undefined &&\r\n\t\tconditionTokens.length > 0\r\n\t) {\r\n\t\tconditionText = conditionTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNode: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess\r\n\t\t\tborderBottom\r\n\t\t\tborderLeft\r\n\t\t/>\r\n\t);\r\n\tif (body.length > 0) {\r\n\t\tbodyNode = body.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`subnode-${index}`}\r\n\t\t\t\tnode={subnode}\r\n\t\t\t\tborderBottom\r\n\t\t\t\tborderLeft\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<Box paddingLeft={2}>{bodyNode}</Box>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{conditionText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramIfElseProps = {\r\n\tconditionTokens?: DiagramToken[];\r\n\tbodyIf: Node[];\r\n\tbodyElse: Node[];\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const DiagramIfElse: FC<\r\n\tDiagramIfElseProps\r\n> = (props) => {\r\n\tconst {\r\n\t\tconditionTokens,\r\n\t\tbodyIf,\r\n\t\tbodyElse,\r\n\t\t...rest\r\n\t} = props;\r\n\r\n\tlet conditionText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tconditionTokens !== undefined &&\r\n\t\tconditionTokens.length > 0\r\n\t) {\r\n\t\tconditionText = conditionTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNodeIf: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess borderTop />\r\n\t);\r\n\tif (bodyIf.length > 0) {\r\n\t\tbodyNodeIf = bodyIf.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`index-${index}`}\r\n\t\t\t\tborderTop\r\n\t\t\t\tnode={subnode}\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\tlet bodyNodeElse: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess borderTop />\r\n\t);\r\n\tif (bodyElse.length > 0) {\r\n\t\tbodyNodeElse = bodyElse.map(\r\n\t\t\t(subnode, index) => (\r\n\t\t\t\t<Diagram\r\n\t\t\t\t\tkey={`index-${index}`}\r\n\t\t\t\t\tborderTop\r\n\t\t\t\t\tnode={subnode}\r\n\t\t\t\t/>\r\n\t\t\t),\r\n\t\t);\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<Grid\r\n\t\t\t\tcontainer\r\n\t\t\t\theight=\"100%\"\r\n\t\t\t>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={12}\r\n\t\t\t\t>\r\n\t\t\t\t\t<DiagramComponentText align=\"center\">\r\n\t\t\t\t\t\t{conditionText}\r\n\t\t\t\t\t</DiagramComponentText>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Box\r\n\t\t\t\t\t\theight=\"100%\"\r\n\t\t\t\t\t\tdisplay=\"flex\"\r\n\t\t\t\t\t\talignItems=\"center\"\r\n\t\t\t\t\t\tjustifyContent=\"center\"\r\n\t\t\t\t\t\tposition=\"relative\"\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<DiagramComponentText\r\n\t\t\t\t\t\t\tsx={{\r\n\t\t\t\t\t\t\t\tzIndex: 2,\r\n\t\t\t\t\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tTrue\r\n\t\t\t\t\t\t</DiagramComponentText>\r\n\t\t\t\t\t\t<ArrowTopLeftBottomRight htmlColor=\"black\" />\r\n\t\t\t\t\t</Box>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Box\r\n\t\t\t\t\t\theight=\"100%\"\r\n\t\t\t\t\t\tdisplay=\"flex\"\r\n\t\t\t\t\t\talignItems=\"center\"\r\n\t\t\t\t\t\tjustifyContent=\"center\"\r\n\t\t\t\t\t\tposition=\"relative\"\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<ArrowBottomLeftTopRight />\r\n\t\t\t\t\t\t<DiagramComponentText\r\n\t\t\t\t\t\t\tsx={{\r\n\t\t\t\t\t\t\t\tzIndex: 2,\r\n\t\t\t\t\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tFalse\r\n\t\t\t\t\t\t</DiagramComponentText>\r\n\t\t\t\t\t</Box>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Stack\r\n\t\t\t\t\t\theight=\"100%\"\r\n\t\t\t\t\t\tsx={{\r\n\t\t\t\t\t\t\tborderColor: \"inherit\",\r\n\t\t\t\t\t\t\tborderRightStyle: \"solid\",\r\n\t\t\t\t\t\t\tborderRightWidth: 2,\r\n\t\t\t\t\t\t}}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t{bodyNodeIf}\r\n\t\t\t\t\t</Stack>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Stack height=\"100%\">\r\n\t\t\t\t\t\t{bodyNodeElse}\r\n\t\t\t\t\t</Stack>\r\n\t\t\t\t</Grid>\r\n\t\t\t</Grid>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramFuncProps = {\r\n\tdeclarationTokens: DiagramToken[];\r\n\tbody: Node[];\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramFunc: FC<DiagramFuncProps> = (\r\n\tprops,\r\n) => {\r\n\tconst { declarationTokens, body, ...rest } =\r\n\t\tprops;\r\n\r\n\tlet declarationText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tdeclarationTokens !== undefined &&\r\n\t\tdeclarationTokens.length > 0\r\n\t) {\r\n\t\tdeclarationText = declarationTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNode: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess\r\n\t\t\tborderTop\r\n\t\t\tborderLeft\r\n\t\t\tborderRight\r\n\t\t/>\r\n\t);\r\n\tif (body.length > 0) {\r\n\t\tbodyNode = body.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`subnode-${index}`}\r\n\t\t\t\tnode={subnode}\r\n\t\t\t\tborderTop\r\n\t\t\t\tborderLeft\r\n\t\t\t\tborderRight\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText align=\"center\">\r\n\t\t\t\t{declarationText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<Box paddingX={2}>{bodyNode}</Box>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramErrorProps = {\r\n\tcontext: string;\r\n\treason: string;\r\n\tlineNumber: number;\r\n\tcharacterNumber: number;\r\n\tcaretOffset: number;\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramError: FC<DiagramErrorProps> = (\r\n\tprops,\r\n) => {\r\n\tconst {\r\n\t\tcontext,\r\n\t\treason,\r\n\t\tlineNumber,\r\n\t\tcharacterNumber,\r\n\t\tcaretOffset,\r\n\r\n\t\t...rest\r\n\t} = props;\r\n\tconst errorText = `At line ${lineNumber}, character ${characterNumber}: ${reason}`;\r\n\tconst caretText = \"~\".repeat(caretOffset) + \"^\";\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{errorText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<DiagramComponentText paddingY={0}>\r\n\t\t\t\t{context}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<DiagramComponentText paddingY={0}>\r\n\t\t\t\t{caretText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramProps = {\r\n\tnode: Node;\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const Diagram: FC<DiagramProps> = (\r\n\tprops,\r\n) => {\r\n\tconst { node, ...rest } = props;\r\n\r\n\tswitch (node.kind) {\r\n\t\tcase DiagramNodeKind.ERROR:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramError\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tcaretOffset={node.caretOffset}\r\n\t\t\t\t\tcontext={node.context}\r\n\t\t\t\t\treason={node.reason}\r\n\t\t\t\t\tlineNumber={node.lineNumber}\r\n\t\t\t\t\tcharacterNumber={node.charNumber}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.FUNCTION:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramFunc\r\n\t\t\t\t\tdeclarationTokens={node.declaration}\r\n\t\t\t\t\tbody={node.body}\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.LOOP_FIRST:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramLoopFirst\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tconditionTokens={node.condition}\r\n\t\t\t\t\tbody={node.body}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.LOOP_LAST:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramLoopLast\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tconditionTokens={node.condition}\r\n\t\t\t\t\tbody={node.body}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.IF_ELSE:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramIfElse\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tconditionTokens={node.condition}\r\n\t\t\t\t\tbodyIf={node.bodyIf}\r\n\t\t\t\t\tbodyElse={node.bodyElse}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.PROCESS:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramProcess\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tbodyTokens={node.body}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t}\r\n\treturn <Fragment />;\r\n};\r\n","import { FC, ReactNode } from \"react\";\r\n\r\nimport {\r\n\tBox,\r\n\tSxProps,\r\n\tTypography,\r\n} from \"@mui/material\";\r\nimport { grey } from \"@mui/material/colors\";\r\n\r\nimport { Node } from \"interpreter\";\r\nimport { Diagram } from \"App/components/Diagram/Diagram\";\r\n\r\ntype DiagramPreviewProps = {\r\n\tnodes: Node[];\r\n\tid: string;\r\n\tboxProps: SxProps;\r\n};\r\nexport const DiagramPreview: FC<\r\n\tDiagramPreviewProps\r\n> = (props): ReactNode => {\r\n\tconst { nodes, id, boxProps } = props;\r\n\r\n\tlet component: ReactNode | ReactNode[] = (\r\n\t\t<Typography\r\n\t\t\tfontFamily=\"inherit\"\r\n\t\t\tfontStyle=\"italic\"\r\n\t\t>\r\n\t\t\tNothing to display.\r\n\t\t</Typography>\r\n\t);\r\n\tif (nodes.length > 0) {\r\n\t\tcomponent = nodes.map((node, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`top-level-node-${index}`}\r\n\t\t\t\tnode={node}\r\n\t\t\t\tborderLeft\r\n\t\t\t\tborderTop\r\n\t\t\t\tborderRight\r\n\t\t\t\tborderBottom={index === nodes.length - 1}\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Box\r\n\t\t\tsx={{\r\n\t\t\t\t...boxProps,\r\n\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\tborderColor: grey[700],\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t<Box\r\n\t\t\t\tid={id}\r\n\t\t\t\tsx={{\r\n\t\t\t\t\tmaxWidth: \"640px\",\r\n\t\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\t\tborderColor: grey[700],\r\n\t\t\t\t}}\r\n\t\t\t>\r\n\t\t\t\t{component}\r\n\t\t\t</Box>\r\n\t\t</Box>\r\n\t);\r\n};\r\n","import { FC } from \"react\";\r\n\r\nimport { Box, SxProps } from \"@mui/material\";\r\nimport ReactCodeMirror from \"@uiw/react-codemirror\";\r\n\r\nimport \"./styles.css\";\r\n\r\ntype StyledCodeEditorProps = {\r\n\tvalue: string;\r\n\tonValueChange?: (value: string) => void;\r\n\tboxProps?: SxProps;\r\n};\r\nexport const StyledCodeEditor: FC<\r\n\tStyledCodeEditorProps\r\n> = (props) => {\r\n\tconst { value, onValueChange, boxProps } =\r\n\t\tprops;\r\n\r\n\treturn (\r\n\t\t<Box sx={boxProps}>\r\n\t\t\t<ReactCodeMirror\r\n\t\t\t\tvalue={value}\r\n\t\t\t\tonChange={onValueChange}\r\n\t\t\t\ttheme=\"dark\"\r\n\t\t\t/>\r\n\t\t</Box>\r\n\t);\r\n};\r\n","import { FC } from \"react\";\r\nimport {\r\n\tButton,\r\n\tButtonProps,\r\n\tTooltip,\r\n} from \"@mui/material\";\r\n\r\ntype AdaptiveButtonProps = ButtonProps & {\r\n\tcollapse: boolean;\r\n};\r\nexport const AdaptiveButton: FC<\r\n\tAdaptiveButtonProps\r\n> = (props) => {\r\n\tconst { collapse, ...rest } = props;\r\n\r\n\tif (collapse) {\r\n\t\treturn (\r\n\t\t\t<Tooltip title={rest.children}>\r\n\t\t\t\t<Button\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tstartIcon={undefined}\r\n\t\t\t\t\tendIcon={undefined}\r\n\t\t\t\t>\r\n\t\t\t\t\t{rest.startIcon}\r\n\t\t\t\t\t{rest.endIcon}\r\n\t\t\t\t</Button>\r\n\t\t\t</Tooltip>\r\n\t\t);\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Button\r\n\t\t\t{...rest}\r\n\t\t\tstartIcon={rest.startIcon}\r\n\t\t\tendIcon={rest.endIcon}\r\n\t\t>\r\n\t\t\t{rest.children}\r\n\t\t</Button>\r\n\t);\r\n};\r\n","import {\r\n\tFC,\r\n\tFragment,\r\n\tuseCallback,\r\n\tuseEffect,\r\n\tuseRef,\r\n\tuseState,\r\n} from \"react\";\r\nimport {\r\n\tBox,\r\n\tGrid,\r\n\tStack,\r\n\tPaper,\r\n\tButton,\r\n\tMenuList,\r\n\tListItemText,\r\n\tButtonGroup,\r\n\tPopover,\r\n\tMenuItem,\r\n\tListItemIcon,\r\n\tuseMediaQuery,\r\n\tTheme,\r\n} from \"@mui/material\";\r\nimport {\r\n\tDownloadRounded,\r\n\tLaunchRounded,\r\n\tSendRounded,\r\n} from \"@mui/icons-material\";\r\nimport { useSnackbar } from \"notistack\";\r\n\r\nimport {\r\n\tlexerGetAllTokens,\r\n\tlexerInit,\r\n\tNode,\r\n\tparserGetAllNodes,\r\n\tparserInit,\r\n} from \"interpreter\";\r\nimport { DiagramPreview } from \"App/components/DiagramPreview\";\r\n\r\nimport { StructogramCodeEditor } from \"App/components/StyledCodeEditor\";\r\nimport { AdaptiveButton } from \"App/components/AdaptiveButton\";\r\nimport { useExportDiagram } from \"App/components/LiveEditor/useExportDiagram\";\r\nimport { useEditorContent } from \"App/components/LiveEditor/useEditorContent\";\r\nimport {\r\n\tgenerateUniqueLink,\r\n\tgetPreviewState,\r\n} from \"App/components/LiveEditor/helper\";\r\n\r\nexport const LiveEditor: FC = () => {\r\n\tconst { enqueueSnackbar } = useSnackbar();\r\n\tconst appBarRef = useRef<HTMLDivElement | null>(\r\n\t\tnull,\r\n\t);\r\n\tconst [\r\n\t\tappBarStaticHeight,\r\n\t\tsetAppBarStaticHeight,\r\n\t] = useState<number>(0);\r\n\tconst matchBreakpointXs = useMediaQuery<Theme>(\r\n\t\t(theme) => theme.breakpoints.down(\"md\"),\r\n\t);\r\n\r\n\tconst { exportJPEG, exportPNG, exportSVG } =\r\n\t\tuseExportDiagram(\r\n\t\t\t\"structogram-preview-region\",\r\n\t\t);\r\n\r\n\tconst { editorContent, setEditorContent } =\r\n\t\tuseEditorContent(\r\n\t\t\twindow.location.href,\r\n\t\t\t\"autosaveContent\",\r\n\t\t);\r\n\r\n\tconst [nodes, setNodes] = useState<Node[]>([]);\r\n\tconst [\r\n\t\tpopoverExportMenuAnchor,\r\n\t\tsetPopoverExportMenuAnchor,\r\n\t] = useState<HTMLButtonElement | null>(null);\r\n\tconst [previewOpen, setPreviewOpen] = useState(\r\n\t\tgetPreviewState(window.location.href),\r\n\t);\r\n\r\n\tuseEffect(() => {\r\n\t\tif (appBarRef.current === null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsetAppBarStaticHeight(\r\n\t\t\tappBarRef.current.getBoundingClientRect()\r\n\t\t\t\t.height,\r\n\t\t);\r\n\t}, [appBarRef]);\r\n\r\n\tuseEffect(() => {\r\n\t\tconst tokens = lexerGetAllTokens(\r\n\t\t\tlexerInit(editorContent),\r\n\t\t);\r\n\t\tconst nodes = parserGetAllNodes(\r\n\t\t\tparserInit(tokens),\r\n\t\t);\r\n\t\tsetNodes(nodes);\r\n\t}, [editorContent]);\r\n\r\n\tconst handlePreviewToggle = useCallback(() => {\r\n\t\tsetPreviewOpen((prev) => !prev);\r\n\t}, []);\r\n\r\n\tconst handleCopyLink = useCallback(() => {\r\n\t\tnavigator.clipboard.writeText(\r\n\t\t\tgenerateUniqueLink(\r\n\t\t\t\teditorContent,\r\n\t\t\t\twindow.location.href,\r\n\t\t\t),\r\n\t\t);\r\n\t\tenqueueSnackbar(\"Link copied to clipboard\", {\r\n\t\t\tvariant: \"info\",\r\n\t\t});\r\n\t}, [enqueueSnackbar, editorContent]);\r\n\r\n\tconst handlePopoverExportMenuOpen = useCallback(\r\n\t\t(\r\n\t\t\tevent: React.MouseEvent<HTMLButtonElement>,\r\n\t\t) => {\r\n\t\t\tsetPopoverExportMenuAnchor(\r\n\t\t\t\tevent.currentTarget,\r\n\t\t\t);\r\n\t\t},\r\n\t\t[],\r\n\t);\r\n\tconst handlePopoverExportMenuClose =\r\n\t\tuseCallback(() => {\r\n\t\t\tsetPopoverExportMenuAnchor(null);\r\n\t\t}, []);\r\n\r\n\tconst handleExportDiagram = async (\r\n\t\texporterFn: () => Promise<boolean>,\r\n\t) => {\r\n\t\texporterFn().then((success) => {\r\n\t\t\tif (success) {\r\n\t\t\t\tenqueueSnackbar(\"Diagram exported\", {\r\n\t\t\t\t\tvariant: \"info\",\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tenqueueSnackbar(\r\n\t\t\t\t\"Failed to export diagram\",\r\n\t\t\t\t{\r\n\t\t\t\t\tvariant: \"error\",\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t});\r\n\t};\r\n\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<Box>\r\n\t\t\t\t<Paper\r\n\t\t\t\t\tref={appBarRef}\r\n\t\t\t\t\tsquare\r\n\t\t\t\t\televation={0}\r\n\t\t\t\t\tsx={{\r\n\t\t\t\t\t\tpadding: 1,\r\n\t\t\t\t\t}}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Stack\r\n\t\t\t\t\t\tdisplay=\"flex\"\r\n\t\t\t\t\t\tdirection=\"row\"\r\n\t\t\t\t\t\tjustifyContent=\"space-between\"\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<ButtonGroup variant=\"outlined\">\r\n\t\t\t\t\t\t\t<Button\r\n\t\t\t\t\t\t\t\tonClick={handlePreviewToggle}\r\n\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\t{previewOpen\r\n\t\t\t\t\t\t\t\t\t? \"Show code\"\r\n\t\t\t\t\t\t\t\t\t: \"Hide code\"}\r\n\t\t\t\t\t\t\t</Button>\r\n\t\t\t\t\t\t\t<Button\r\n\t\t\t\t\t\t\t\thref=\"https://eurydia.github.io/project-nassi-shneiderman-diagram-builder-online-docs/\"\r\n\t\t\t\t\t\t\t\tcomponent=\"a\"\r\n\t\t\t\t\t\t\t\ttarget=\"_blank\"\r\n\t\t\t\t\t\t\t\tendIcon={<LaunchRounded />}\r\n\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\tdocs\r\n\t\t\t\t\t\t\t</Button>\r\n\t\t\t\t\t\t</ButtonGroup>\r\n\t\t\t\t\t\t<ButtonGroup variant=\"outlined\">\r\n\t\t\t\t\t\t\t<AdaptiveButton\r\n\t\t\t\t\t\t\t\tcollapse={matchBreakpointXs}\r\n\t\t\t\t\t\t\t\tstartIcon={<DownloadRounded />}\r\n\t\t\t\t\t\t\t\tonClick={\r\n\t\t\t\t\t\t\t\t\thandlePopoverExportMenuOpen\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\tEXPORT\r\n\t\t\t\t\t\t\t</AdaptiveButton>\r\n\t\t\t\t\t\t\t<AdaptiveButton\r\n\t\t\t\t\t\t\t\tcollapse={matchBreakpointXs}\r\n\t\t\t\t\t\t\t\tendIcon={<SendRounded />}\r\n\t\t\t\t\t\t\t\tonClick={handleCopyLink}\r\n\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\tSHARE\r\n\t\t\t\t\t\t\t</AdaptiveButton>\r\n\t\t\t\t\t\t</ButtonGroup>\r\n\t\t\t\t\t</Stack>\r\n\t\t\t\t</Paper>\r\n\t\t\t\t<Box>\r\n\t\t\t\t\t<Grid container>\r\n\t\t\t\t\t\t<Grid\r\n\t\t\t\t\t\t\titem\r\n\t\t\t\t\t\t\txs={12}\r\n\t\t\t\t\t\t\tlg={6}\r\n\t\t\t\t\t\t\tdisplay={\r\n\t\t\t\t\t\t\t\tpreviewOpen ? \"none\" : undefined\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<StructogramCodeEditor\r\n\t\t\t\t\t\t\t\tvalue={editorContent}\r\n\t\t\t\t\t\t\t\tonValueChange={setEditorContent}\r\n\t\t\t\t\t\t\t\tboxProps={{\r\n\t\t\t\t\t\t\t\t\toverflowY: \"auto\",\r\n\t\t\t\t\t\t\t\t\theight: `calc(100vh - ${appBarStaticHeight}px)`,\r\n\t\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t\t/>\r\n\t\t\t\t\t\t</Grid>\r\n\t\t\t\t\t\t<Grid\r\n\t\t\t\t\t\t\titem\r\n\t\t\t\t\t\t\txs\r\n\t\t\t\t\t\t\tlg\r\n\t\t\t\t\t\t\tdisplay={\r\n\t\t\t\t\t\t\t\tmatchBreakpointXs && !previewOpen\r\n\t\t\t\t\t\t\t\t\t? \"none\"\r\n\t\t\t\t\t\t\t\t\t: undefined\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<DiagramPreview\r\n\t\t\t\t\t\t\t\tnodes={nodes}\r\n\t\t\t\t\t\t\t\tid=\"structogram-preview-region\"\r\n\t\t\t\t\t\t\t\tboxProps={{\r\n\t\t\t\t\t\t\t\t\tpadding: 4,\r\n\t\t\t\t\t\t\t\t\toverflowY: \"auto\",\r\n\t\t\t\t\t\t\t\t\tuserSelect: \"none\",\r\n\t\t\t\t\t\t\t\t\theight: `calc(100vh - ${appBarStaticHeight}px)`,\r\n\t\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t\t/>\r\n\t\t\t\t\t\t</Grid>\r\n\t\t\t\t\t</Grid>\r\n\t\t\t\t</Box>\r\n\t\t\t</Box>\r\n\t\t\t<Popover\r\n\t\t\t\tanchorOrigin={{\r\n\t\t\t\t\tvertical: \"bottom\",\r\n\t\t\t\t\thorizontal: \"left\",\r\n\t\t\t\t}}\r\n\t\t\t\ttransformOrigin={{\r\n\t\t\t\t\tvertical: \"top\",\r\n\t\t\t\t\thorizontal: \"left\",\r\n\t\t\t\t}}\r\n\t\t\t\tanchorEl={popoverExportMenuAnchor}\r\n\t\t\t\topen={popoverExportMenuAnchor !== null}\r\n\t\t\t\tonClose={handlePopoverExportMenuClose}\r\n\t\t\t>\r\n\t\t\t\t<Paper\r\n\t\t\t\t\tsx={{\r\n\t\t\t\t\t\tpadding: 1,\r\n\t\t\t\t\t}}\r\n\t\t\t\t>\r\n\t\t\t\t\t<MenuList>\r\n\t\t\t\t\t\t<MenuItem\r\n\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\thandleExportDiagram(exportJPEG)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<ListItemIcon>\r\n\t\t\t\t\t\t\t\t<DownloadRounded fontSize=\"small\" />\r\n\t\t\t\t\t\t\t</ListItemIcon>\r\n\t\t\t\t\t\t\t<ListItemText>\r\n\t\t\t\t\t\t\t\tSave as JPEG\r\n\t\t\t\t\t\t\t</ListItemText>\r\n\t\t\t\t\t\t</MenuItem>\r\n\t\t\t\t\t\t<MenuItem\r\n\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\thandleExportDiagram(exportPNG)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<ListItemIcon>\r\n\t\t\t\t\t\t\t\t<DownloadRounded fontSize=\"small\" />\r\n\t\t\t\t\t\t\t</ListItemIcon>\r\n\t\t\t\t\t\t\t<ListItemText>\r\n\t\t\t\t\t\t\t\tSave as PNG\r\n\t\t\t\t\t\t\t</ListItemText>\r\n\t\t\t\t\t\t</MenuItem>\r\n\t\t\t\t\t\t<MenuItem\r\n\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\thandleExportDiagram(exportSVG)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<ListItemIcon>\r\n\t\t\t\t\t\t\t\t<DownloadRounded fontSize=\"small\" />\r\n\t\t\t\t\t\t\t</ListItemIcon>\r\n\t\t\t\t\t\t\t<ListItemText>\r\n\t\t\t\t\t\t\t\tSave as SVG\r\n\t\t\t\t\t\t\t</ListItemText>\r\n\t\t\t\t\t\t</MenuItem>\r\n\t\t\t\t\t</MenuList>\r\n\t\t\t\t</Paper>\r\n\t\t\t</Popover>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n","// Custom hooks for exporting diagrams\r\n\r\nimport { useCallback } from \"react\";\r\nimport { saveAs } from \"file-saver\";\r\nimport {\r\n\ttoJpeg,\r\n\ttoPng,\r\n\ttoSvg,\r\n} from \"html-to-image\";\r\n\r\nexport const useExportDiagram = (\r\n\ttargetElementId: string,\r\n) => {\r\n\tconst exportSVG = useCallback(async () => {\r\n\t\tconst HTMLNode = document.getElementById(\r\n\t\t\ttargetElementId,\r\n\t\t);\r\n\t\tif (HTMLNode === null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn toSvg(HTMLNode).then((blob) => {\r\n\t\t\tif (blob === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tsaveAs(blob, \"structogram\");\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}, [targetElementId]);\r\n\r\n\tconst exportPNG = useCallback(async () => {\r\n\t\tconst HTMLNode = document.getElementById(\r\n\t\t\ttargetElementId,\r\n\t\t);\r\n\t\tif (HTMLNode === null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn toPng(HTMLNode).then((blob) => {\r\n\t\t\tif (blob === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tsaveAs(blob, \"structogram\");\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}, [targetElementId]);\r\n\r\n\tconst exportJPEG = useCallback(async () => {\r\n\t\tconst HTMLNode = document.getElementById(\r\n\t\t\ttargetElementId,\r\n\t\t);\r\n\t\tif (HTMLNode === null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn toJpeg(HTMLNode).then((blob) => {\r\n\t\t\tif (blob === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tsaveAs(blob, \"structogram\");\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}, [targetElementId]);\r\n\r\n\treturn {\r\n\t\texportSVG,\r\n\t\texportJPEG,\r\n\t\texportPNG,\r\n\t};\r\n};\r\n","// Custom hook for editor content\r\n\r\nimport { useCallback, useState } from \"react\";\r\n\r\nexport const useEditorContent = (\r\n\threfURL: string,\r\n\tlocalStorageKey: string,\r\n) => {\r\n\tconst [editorContent, setEditorContentInner] =\r\n\t\tuseState(() => {\r\n\t\t\tconst url = new URL(hrefURL);\r\n\r\n\t\t\tconst content =\r\n\t\t\t\turl.searchParams.get(\"content\");\r\n\t\t\tif (content !== null) {\r\n\t\t\t\twindow.localStorage.setItem(\r\n\t\t\t\t\tlocalStorageKey,\r\n\t\t\t\t\tcontent,\r\n\t\t\t\t);\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\r\n\t\t\tconst savedContent =\r\n\t\t\t\twindow.localStorage.getItem(\r\n\t\t\t\t\tlocalStorageKey,\r\n\t\t\t\t);\r\n\t\t\tif (savedContent !== null) {\r\n\t\t\t\treturn savedContent;\r\n\t\t\t}\r\n\t\t\treturn \"\";\r\n\t\t});\r\n\r\n\tconst setEditorContent = useCallback(\r\n\t\t(v: string) => {\r\n\t\t\tsetEditorContentInner(v);\r\n\t\t\twindow.localStorage.setItem(\r\n\t\t\t\tlocalStorageKey,\r\n\t\t\t\tv,\r\n\t\t\t);\r\n\t\t},\r\n\t\t[localStorageKey],\r\n\t);\r\n\r\n\treturn { editorContent, setEditorContent };\r\n};\r\n","export const generateUniqueLink = (\r\n\teditorContent: string,\r\n\tlocationHref: string,\r\n) => {\r\n\tconst url = new URL(locationHref);\r\n\turl.searchParams.set(\"preview\", \"true\");\r\n\turl.searchParams.set(\"content\", editorContent);\r\n\treturn url.href;\r\n};\r\n\r\nexport const getPreviewState = (\r\n\tlocationHref: string,\r\n): boolean => {\r\n\tconst url = new URL(locationHref);\r\n\tconst previewParam =\r\n\t\turl.searchParams.get(\"preview\");\r\n\treturn (\r\n\t\tpreviewParam !== null &&\r\n\t\tpreviewParam === \"true\"\r\n\t);\r\n};\r\n","import { Fragment, FC } from \"react\";\r\nimport {\r\n\tCssBaseline,\r\n\tThemeProvider,\r\n\tcreateTheme,\r\n} from \"@mui/material\";\r\n\r\nimport { SnackbarProvider } from \"notistack\";\r\n\r\nimport { LiveEditor } from \"App/components/LiveEditor/LiveEditor\";\r\n\r\nconst themeDark = createTheme({\r\n\tpalette: {\r\n\t\tmode: \"dark\",\r\n\t},\r\n});\r\n\r\nexport const App: FC = () => {\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<CssBaseline />\r\n\t\t\t<ThemeProvider theme={themeDark}>\r\n\t\t\t\t<SnackbarProvider\r\n\t\t\t\t\tpreventDuplicate\r\n\t\t\t\t\tautoHideDuration={2000}\r\n\t\t\t\t\tanchorOrigin={{\r\n\t\t\t\t\t\tvertical: \"top\",\r\n\t\t\t\t\t\thorizontal: \"center\",\r\n\t\t\t\t\t}}\r\n\t\t\t\t>\r\n\t\t\t\t\t<LiveEditor />\r\n\t\t\t\t</SnackbarProvider>\r\n\t\t\t</ThemeProvider>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom/client\";\r\n\r\nimport { App } from \"./App\";\r\n\r\nReactDOM.createRoot(\r\n\tdocument.getElementById(\"root\")!,\r\n).render(\r\n\t<React.StrictMode>\r\n\t\t<App />\r\n\t</React.StrictMode>,\r\n);\r\n"],"names":["DiagramTokenKind","DiagramTokenKind2","KEYWORDS","LITERAL_TOKENS","lexerGetNextTokenThenAdvance","l","token","kind","text","lineNumber","cursorRow","charNumber","cursorCol","cursorPos","contentLength","content","test","includes","DiagramNodeKind","DiagramNodeKind2","parserInit","tokens","tokenLength","length","parserCollectTokensBetween","p","startToken","stopToken","depth","push","parserSkipWhiteSpace","WHITE_SPACE","parserGetNextNodeThenAdvance","KEYWORD","node","body","condition","markerToken","reason","context","caretOffset","LEFT_PAREN","markerTokenText","errorTokenText","RIGHT_PAREN","pop","LEFT_CURLY","bodyTokens","RIGHT_CURLY","parserGetAllNodes","parserBuildLoopFirstNode","SEMICOLON","parserBuildLoopLastNode","bodyIf","bodyElse","bodyIfTokens","bodyElseTokens","parserBuildIfElseNode","rowPos","colPos","declaration","nodes","ArrowTopLeftBottomRight","props","sx","jsxRuntimeExports","jsx","SvgIcon","position","width","height","children","xmlns","preserveAspectRatio","fill","viewBox","strokeWidth","x1","y1","x2","y2","stroke","strokeLinecap","ArrowBottomLeftTopRight","DiagramWrapper","borderTop","borderBottom","borderLeft","borderRight","Box","borderStyle","borderLeftWidth","borderTopWidth","borderBottomWidth","borderRightWidth","DiagramComponentText","rest","Typography","padding","fontFamily","wordBreak","fontVariantLigatures","DiagramProcess","bodyText","map","join","trim","DiagramLoopFirst","conditionTokens","conditionText","bodyNode","subnode","index","Diagram","jsxs","paddingLeft","DiagramLoopLast","DiagramIfElse","bodyNodeIf","bodyNodeElse","Grid","container","item","xs","align","display","alignItems","justifyContent","zIndex","backgroundColor","grey","htmlColor","Stack","borderColor","borderRightStyle","DiagramFunc","declarationTokens","declarationText","paddingX","DiagramError","characterNumber","errorText","caretText","repeat","paddingY","ERROR","FUNCTION","LOOP_FIRST","LOOP_LAST","IF_ELSE","PROCESS","Fragment","DiagramPreview","id","boxProps","component","fontStyle","maxWidth","StyledCodeEditor","value","onValueChange","ReactCodeMirror","onChange","theme","AdaptiveButton","collapse","Tooltip","title","Button","startIcon","endIcon","LiveEditor","enqueueSnackbar","useSnackbar","appBarRef","useRef","appBarStaticHeight","setAppBarStaticHeight","useState","matchBreakpointXs","useMediaQuery","breakpoints","down","exportJPEG","exportPNG","exportSVG","targetElementId","useCallback","async","HTMLNode","document","getElementById","toSvg","then","blob","toPng","toJpeg","useExportDiagram","editorContent","setEditorContent","hrefURL","localStorageKey","setEditorContentInner","URL","searchParams","get","window","localStorage","setItem","savedContent","getItem","v","useEditorContent","location","href","setNodes","popoverExportMenuAnchor","setPopoverExportMenuAnchor","previewOpen","setPreviewOpen","locationHref","previewParam","getPreviewState","useEffect","current","getBoundingClientRect","lexerGetAllTokens","cleanedContent","cleanContent","contentPos","removeComments","normalize","lexerInit","handlePreviewToggle","prev","handleCopyLink","navigator","clipboard","writeText","url","set","generateUniqueLink","variant","handlePopoverExportMenuOpen","event","currentTarget","handlePopoverExportMenuClose","handleExportDiagram","exporterFn","success","Paper","ref","square","elevation","direction","ButtonGroup","onClick","target","LaunchRounded","DownloadRounded","SendRounded","lg","StructogramCodeEditor","overflowY","userSelect","Popover","anchorOrigin","vertical","horizontal","transformOrigin","anchorEl","open","onClose","MenuList","MenuItem","ListItemIcon","fontSize","ListItemText","themeDark","createTheme","palette","mode","App","CssBaseline","ThemeProvider","SnackbarProvider","preventDuplicate","autoHideDuration","ReactDOM","createRoot","render","React","StrictMode"],"mappings":"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"}