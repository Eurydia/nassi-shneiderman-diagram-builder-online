{"version":3,"file":"index-rD1tsR_u.js","sources":["../../src/core/lexer.ts","../../src/core/parser.ts","../../src/App/components/Diagram/ArrowTopLeftBottomRight.tsx","../../src/App/components/Diagram/ArrowBottomLeftTopRight.tsx","../../src/App/components/Diagram/Diagram.tsx","../../src/App/components/DiagramPreview.tsx","../../src/App/components/StyledCodeEditor/StyledCodeEditor.tsx","../../src/App/components/AdaptiveButton.tsx","../../src/App/components/LiveEditor/Layout.tsx","../../src/App/components/LiveEditor/helper.ts","../../src/App/components/LiveEditor/LiveEditor.tsx","../../src/App/components/LiveEditor/useExportDiagram.ts","../../src/App/components/LiveEditor/useEditorContent.ts","../../src/App/App.tsx","../../src/main.tsx"],"sourcesContent":["/**\r\n * This module provides implementation for a lexer.\r\n * The language I have created is simple and the lexer is designed to be simple as well.\r\n */\r\n// ---------------------------------------------\r\n/**\r\n * The \"DiagramTokenKind\" enum categorizes the different types of tokens that the lexer recognizes.\r\n * Each \"DiagramToken\" object is assigned a \"TokenKind\" member as its \"kind\" property.\r\n */\r\nexport enum DiagramTokenKind {\r\n\t/**\r\n\t * This member represents the end of input.\r\n\t * It marks the end of tokenization process.\r\n\t */\r\n\tEOF = 0,\r\n\r\n\t/**\r\n\t * This member represents a word, more specifically, any sequence of non-whitespace characters.\r\n\t * Essentially, any contiguous sequence of characters excluding whitespace is categorized by this member.\r\n\t */\r\n\tSYMBOL,\r\n\r\n\t/**\r\n\t * This member represents reserved keywords.\r\n\t * It is a subset of \"SYMBOL\" member and is used to categorize reserved keywords in the language.\r\n\t * During tokenization, keywords start off as a \"SYMBOL\" member and is then categorized as a \"KEYWORD\" member.\r\n\t */\r\n\tKEYWORD,\r\n\r\n\t/**\r\n\t * This member represents any whitespace characters.\r\n\t * More specfically, it matches characters defined by \"\\s\" [character class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).\r\n\t */\r\n\tWHITE_SPACE,\r\n\r\n\t/**\r\n\t * This member represents a left parenthesis \"(\" literal.\r\n\t */\r\n\tLEFT_PAREN,\r\n\r\n\t/**\r\n\t * This member represents a right parenthesis \")\" literal.\r\n\t */\r\n\tRIGHT_PAREN,\r\n\r\n\t/**\r\n\t * This member represents a left curly brace \"{\" literal.\r\n\t * */\r\n\tLEFT_CURLY,\r\n\r\n\t/**\r\n\t * This member represents a right curly brace \"}\" literal.\r\n\t * */\r\n\tRIGHT_CURLY,\r\n\r\n\t/**\r\n\t * This member represents a semicolon \";\" literal.\r\n\t * */\r\n\tSEMICOLON,\r\n}\r\n\r\n/**\r\n * A \"Token\" object represents a tokenized input.\r\n * It encapsulates a meaningful sequence of characters and provides addition context and information about the token's.\r\n */\r\nexport type DiagramToken = {\r\n\t/**\r\n\t * The kind of token.\r\n\t * */\r\n\tkind: DiagramTokenKind;\r\n\r\n\t/**\r\n\t * The string associated with the token.\r\n\t */\r\n\ttext: string;\r\n\r\n\t/**\r\n\t * The line number where the token is located.\r\n\t * It is 1-indexed and starts counting from the position of the first character in the string.\r\n\t */\r\n\tlineNumber: number;\r\n\r\n\t/**\r\n\t * The character number where the token is located.\r\n\t * It is 1-indexed, and starts counting from the position of the first character in the string\r\n\t */\r\n\tcharNumber: number;\r\n};\r\n\r\n/**\r\n * The \"KEYWORDS\" array defines a list of reserved keywords for the lexer.\r\n * The intention is to define a centralized collection of keywords.\r\n *\r\n * During tokenization process, the lexer checks if each word is in this array.\r\n * If it is, it updates the \"kind\" property of that \"DiagramToken\" object with \"DiagramTokenKind.KEYWORD\" member.\r\n */\r\nconst KEYWORDS: string[] = [\r\n\t\"for\",\r\n\t\"if\",\r\n\t\"else\",\r\n\t\"while\",\r\n\t\"do\",\r\n];\r\n\r\n/**\r\n * The \"LITERAL_TOKENS\" record defines a mapping of literal characters to the appropriate \"DiagramTokenKind\" members.\r\n * The intention is similar to \"KEYWORDS\" array, but for literal characters.\r\n *\r\n * During tokenization, the lexer checks if each character is a key of this record.\r\n * If it is, it updates the \"kind\" property of that \"DiagramToken\" object with corresponding value of that key.\r\n */\r\nconst LITERAL_TOKENS: Record<\r\n\tstring,\r\n\tDiagramTokenKind\r\n> = {\r\n\t\"{\": DiagramTokenKind.LEFT_CURLY,\r\n\t\"}\": DiagramTokenKind.RIGHT_CURLY,\r\n\t\"(\": DiagramTokenKind.LEFT_PAREN,\r\n\t\")\": DiagramTokenKind.RIGHT_PAREN,\r\n\t\";\": DiagramTokenKind.SEMICOLON,\r\n};\r\n\r\n/**\r\n * The \"Lexer\" object represents a lexer.\r\n */\r\nexport type Lexer = {\r\n\t/**\r\n\t * The input string to be tokenized.\r\n\t */\r\n\tcontent: string;\r\n\r\n\t/**\r\n\t * The length of the input string.\r\n\t */\r\n\tcontentLength: number;\r\n\r\n\t/**\r\n\t * The current position of the cursor in the input string.\r\n\t */\r\n\tcursorPos: number;\r\n\r\n\t/**\r\n\t * The current line number.\r\n\t * It is 1-indexed and increments when the lexer encounters a newline character.\r\n\t */\r\n\tlineNumber: number;\r\n\r\n\t/**\r\n\t * The current character number.\r\n\t * It is 1-indexed and increments when the lexer encounters any character.\r\n\t * It resets to one when moving to the next line.\r\n\t */\r\n\tcharNumber: number;\r\n};\r\n\r\n/**\r\n * The \"removeComments\" function takes in an input string, removes comments from it, and returns a string the comments removed.\r\n *\r\n * This function is a preprocessor, and it is called by the \"lexerInit\" function.\r\n */\r\nconst removeComments = (\r\n\tcontent: string,\r\n): string => {\r\n\tlet preprocessedContent = \"\";\r\n\r\n\t// The idea is to iterate through each character in the input string.\r\n\t// If a specific sequence of characters is encountered, the function skips all characters until the end of the line.\r\n\t// To clarify to \"skip\" is simply to not include the characters in the \"cleanContent\" variable.\r\n\tlet contentPos = 0;\r\n\twhile (contentPos < content.length) {\r\n\t\t// If both the current character abd the next character are forward slashes, skip all characters.\r\n\t\tif (\r\n\t\t\tcontentPos + 1 < content.length &&\r\n\t\t\tcontent[contentPos] === \"/\" &&\r\n\t\t\tcontent[contentPos + 1] === \"/\"\r\n\t\t) {\r\n\t\t\t// It is important to note that the newline character is included in the \"cleanContent\" variable.\r\n\t\t\twhile (\r\n\t\t\t\tcontentPos < content.length &&\r\n\t\t\t\tcontent[contentPos] !== \"\\n\"\r\n\t\t\t) {\r\n\t\t\t\tcontentPos++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpreprocessedContent += content[contentPos];\r\n\t\tcontentPos++;\r\n\t}\r\n\treturn preprocessedContent;\r\n};\r\n\r\n/**\r\n * The \"lexerInit\" function initializes a \"Lexer\" object from the given input string.\r\n */\r\nexport const lexerInit = (\r\n\tcontent: string,\r\n): Lexer => {\r\n\t// Calling \"String.normalize()\"on input string is important due to the way accented characters behave.\r\n\t// See discussion on accented characters https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript\r\n\tconst preprocessedContent = removeComments(\r\n\t\tcontent.normalize(),\r\n\t);\r\n\treturn {\r\n\t\tcontent: preprocessedContent,\r\n\t\tcontentLength: preprocessedContent.length,\r\n\t\tcursorPos: 0,\r\n\t\tlineNumber: 1,\r\n\t\tcharNumber: 1,\r\n\t};\r\n};\r\n\r\n/**\r\n * The \"lexerGetNextToken\" function tokenizes a token, returns it, and advances the cursor position.\r\n *\r\n * This function is resposible for the actual tokenization process.\r\n */\r\nconst lexerGetNextToken = (\r\n\tl: Lexer,\r\n): DiagramToken => {\r\n\t// The \"token\" variable stores the tokenized input.\r\n\t// The properties of this token are updated and corrected as the function tokenizes the input string.\r\n\tconst token: DiagramToken = {\r\n\t\tkind: DiagramTokenKind.EOF,\r\n\t\ttext: \"\",\r\n\t\tlineNumber: l.lineNumber,\r\n\t\tcharNumber: l.charNumber,\r\n\t};\r\n\r\n\t// If there is no character left in the input string, return the \"token\" object.\r\n\tif (l.cursorPos >= l.contentLength) {\r\n\t\treturn token;\r\n\t}\r\n\r\n\t// There is at least one character left, consume it, and advance the \"charNumber\" and \"cursorPos\".\r\n\ttoken.text = l.content[l.cursorPos];\r\n\tl.cursorPos++;\r\n\tl.charNumber++;\r\n\r\n\t// If the consumed character is a whitespace character, update the \"kind\" property of the \"token\" object to \"DiagramTokenKind.WHITE_SPACE\" and return it.\r\n\tif (/\\s/.test(token.text)) {\r\n\t\ttoken.kind = DiagramTokenKind.WHITE_SPACE;\r\n\t\t// If the consumed character is also a newline character, update the \"lineNumber\" and \"charNumber\" properties of the \"Lexer\" object.\r\n\t\tif (token.text === \"\\n\") {\r\n\t\t\tl.lineNumber++;\r\n\t\t\tl.charNumber = 1;\r\n\t\t}\r\n\t\treturn token;\r\n\t}\r\n\r\n\t// If the consumed character is not a white space character, but one of the literal tokens, update the \"kind\" property of the \"token\" object to the corresponding value in \"LITERAL_TOKENS\" record and return it.\r\n\tif (token.text in LITERAL_TOKENS) {\r\n\t\ttoken.kind = LITERAL_TOKENS[token.text];\r\n\t\treturn token;\r\n\t}\r\n\r\n\t// If the consumed character is not a white space character, and not one of the literal tokens, consume all characters until the next white space character or literal token.\r\n\twhile (\r\n\t\tl.cursorPos < l.contentLength &&\r\n\t\t!(l.content[l.cursorPos] in LITERAL_TOKENS) &&\r\n\t\t!/\\s/.test(l.content[l.cursorPos])\r\n\t) {\r\n\t\ttoken.text += l.content[l.cursorPos];\r\n\t\tl.cursorPos++;\r\n\t\tl.charNumber++;\r\n\t}\r\n\r\n\t// Once a white space character or literal token is encountered, check whether the consumed sequence of characters is a keyword.\r\n\t// If it is, update the \"kind\" property of the \"token\" object to \"DiagramTokenKind.KEYWORD\" and return it.\r\n\tif (KEYWORDS.includes(token.text)) {\r\n\t\ttoken.kind = DiagramTokenKind.KEYWORD;\r\n\t\treturn token;\r\n\t}\r\n\r\n\t// If the consumed sequence of characters is not a keyword, update the \"kind\" property of the \"token\" object to \"DiagramTokenKind.SYMBOL\" and return it.\r\n\ttoken.kind = DiagramTokenKind.SYMBOL;\r\n\treturn token;\r\n};\r\n\r\n/**\r\n * The \"lexerGetAllTokens\" function tokenizes the entire input string at once.\r\n * The intention is to provide a convenient way to tokenize the entire input string without having to call \"lexerGetNextToken\" function multiple times.\r\n */\r\nexport const lexerGetAllTokens = (\r\n\tl: Lexer,\r\n): DiagramToken[] => {\r\n\tconst tokens: DiagramToken[] = [];\r\n\tlet token: DiagramToken;\r\n\t// The idea is to call \"lexerGetNextToken\" function until a token with \"EOF\" member is returned.\r\n\t// The \"EOF\" token is not included in the returned array.\r\n\r\n\twhile (\r\n\t\t(token = lexerGetNextToken(l)).kind !==\r\n\t\tDiagramTokenKind.EOF\r\n\t) {\r\n\t\ttokens.push(token);\r\n\t}\r\n\r\n\treturn tokens;\r\n};\r\n","import {\r\n\tDiagramToken,\r\n\tDiagramTokenKind,\r\n} from \"./lexer\";\r\n/**\r\n * This module provides implementation for parsers which are needed to convert a list of tokens into an abstract syntax tree.\r\n */\r\n// ---------------------------------------------\r\n\r\n/**\r\n * The `DiagramNodeKind` enumeration represents different kinds of nodes that can appear in the abstract syntax tree.\r\n * Each \"DiagramNode\" object is assigned a \"DiagramNodeKind\" member as its \"kind\" property.\r\n */\r\nexport enum DiagramNodeKind {\r\n\t/**\r\n\t * This member represents the end of the abstract syntax tree.\r\n\t * It signals the end of parsing process.\r\n\t */\r\n\tEND = 0,\r\n\r\n\t/**\r\n\t * This member represents a parsing error.\r\n\t * It signals syntax errors and the end of parsing process.\r\n\t */\r\n\tERROR,\r\n\r\n\t/**\r\n\t * This member represents a process node.\r\n\t * It is the catch-all category for any sequence of tokens that do not fit into any other category.\r\n\t */\r\n\tPROCESS,\r\n\r\n\t/**\r\n\t * This member represents a test-first loop node for \"for\" and \"while\" loops.\r\n\t */\r\n\tLOOP_FIRST,\r\n\r\n\t/**\r\n\t * This member represents a test-last loop node for \"do-while\" loops.\r\n\t */\r\n\tLOOP_LAST,\r\n\r\n\t/**\r\n\t * This member represents an if-else branching node for \"if\" and \"if-else\" blocks.\r\n\t */\r\n\tIF_ELSE,\r\n\r\n\t/**\r\n\t * This member represents a function node.\r\n\t */\r\n\tFUNCTION,\r\n}\r\n\r\n/**\r\n * The \"DiagramNodeEnd\" object represents the end of the parsing process.\r\n */\r\ntype DiagramNodeEnd = {\r\n\tkind: DiagramNodeKind.END;\r\n};\r\n\r\n/**\r\n * The \"DiagramNodeError\" object represents a parsing error.\r\n */\r\ntype DiagramNodeError = {\r\n\tkind: DiagramNodeKind.ERROR;\r\n\t/**\r\n\t * The line number where the error occurred.\r\n\t * It is 1-indexed, and starts counting from the position of the first character in the string.\r\n\t */\r\n\tlineNumber: number;\r\n\r\n\t/**\r\n\t * The character number where the error occurred.\r\n\t * It is 1-indexed, and starts counting from the position of the first character in the string.\r\n\t */\r\n\tcharNumber: number;\r\n\r\n\t/**\r\n\t * The point in which an error occurred and its surrounding context.\r\n\t */\r\n\tcontext: string;\r\n\r\n\t/**\r\n\t * The number of characters to offset the caret from the start of the context string.\r\n\t * It helps to visually indicate the location of the error within the \"context\" string.\r\n\t */\r\n\tcaretOffset: number;\r\n\r\n\t/**\r\n\t * The reason and explanation for the error.\r\n\t */\r\n\treason: string;\r\n};\r\n\r\n/**\r\n * The \"DiagramNodeProcess\" object represents a process block.\r\n */\r\ntype DiagramNodeProcess = {\r\n\tkind: DiagramNodeKind.PROCESS;\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramToken\" objects that make up the body of the process.\r\n\t */\r\n\tbody: DiagramToken[];\r\n};\r\n\r\n/**\r\n * The \"DiagramNodeLoopFirst\" object represents a test-first loop.\r\n */\r\ntype DiagramNodeLoopFirst = {\r\n\tkind: DiagramNodeKind.LOOP_FIRST;\r\n\r\n\t/**\r\n\t * The sequence of `DiagramToken` objects that make up the condition.\r\n\t */\r\n\tcondition: DiagramToken[];\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramNode\" objects that make up the body of the loop.\r\n\t * They are collected as \"DiagramToken\" objects and recursively parsed into \"DiagramNode\" objects.\r\n\t */\r\n\tbody: DiagramNode[];\r\n};\r\n\r\n/**\r\n * The \"DiagramNodeLoopLast\" object represents a test-last loop.\r\n */\r\ntype DiagramNodeLoopLast = {\r\n\tkind: DiagramNodeKind.LOOP_LAST;\r\n\r\n\t/**\r\n\t * The sequence of `DiagramToken` objects that make up the condition.\r\n\t */\r\n\tcondition: DiagramToken[];\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramNode\" objects that make up the body of the loop.\r\n\t * They are collected as \"DiagramToken\" objects and recursively parsed into \"DiagramNode\" objects.\r\n\t */\r\n\tbody: DiagramNode[];\r\n};\r\n\r\n/**\r\n * The \"DiagramNodeIfElse\" object represents a branching block.\r\n */\r\ntype DiagramNodeIfElse = {\r\n\tkind: DiagramNodeKind.IF_ELSE;\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramToken\" objects that make up the condition.\r\n\t */\r\n\tcondition: DiagramToken[];\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramNode\" objects that make up the body of the if branch.\r\n\t * They are collected as \"DiagramToken\" objects and recursively parsed into \"DiagramNode\" objects.\r\n\t */\r\n\tbodyIf: DiagramNode[];\r\n\r\n\t/**\r\n\t * Same as \"bodyIf\" but for the else branch.\r\n\t */\r\n\tbodyElse: DiagramNode[];\r\n};\r\n\r\n/**\r\n * The \"DiagramNodeFunction\" object represents a function.\r\n */\r\ntype DiagramNodeFunction = {\r\n\tkind: DiagramNodeKind.FUNCTION;\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramToken\" objects that make up the function declaration.\r\n\t */\r\n\tdeclaration: DiagramToken[];\r\n\r\n\t/**\r\n\t * The sequence of \"DiagramNode\" objects that make up the body of the function.\r\n\t * They are collected as \"DiagramToken\" objects and recursively parsed into \"DiagramNode\" objects.\r\n\t */\r\n\tbody: DiagramNode[];\r\n};\r\n\r\n/**\r\n * The \"DiagramNode\" union type represents different kinds of nodes that can appear in the abstract syntax tree.\r\n */\r\nexport type DiagramNode =\r\n\t| DiagramNodeEnd\r\n\t| DiagramNodeProcess\r\n\t| DiagramNodeLoopFirst\r\n\t| DiagramNodeLoopLast\r\n\t| DiagramNodeIfElse\r\n\t| DiagramNodeFunction\r\n\t| DiagramNodeError;\r\n\r\n/**\r\n * The \"Parser\" object represents a parser.\r\n * It is used to convert a list of tokens into an abstract syntax tr\r\n */\r\nexport type Parser = {\r\n\t/**\r\n\t * The list of tokens to be parsed.\r\n\t */\r\n\ttokens: DiagramToken[];\r\n\r\n\t/**\r\n\t * The number of tokens in the list.\r\n\t */\r\n\ttokenLength: number;\r\n\r\n\t/**\r\n\t * The position of the cursor in the list.\r\n\t */\r\n\tcursorPos: number;\r\n};\r\n\r\n/**\r\n * The \"parserInit\" function initializes a \"Parser\" object with the given sequence of \"DiagramToken\" objects.\r\n */\r\nexport const parserInit = (\r\n\ttokens: DiagramToken[],\r\n): Parser => {\r\n\treturn {\r\n\t\ttokens: tokens,\r\n\t\ttokenLength: tokens.length,\r\n\t\tcursorPos: 0,\r\n\t};\r\n};\r\n\r\n/**\r\n * The \"parserCollectTokensBetween\" function collects tokens between two given tokens.\r\n * The primary use case is to collect tokens between a pair od parentheses or curly braces.\r\n */\r\nconst parserCollectTokensBetween = (\r\n\tp: Parser,\r\n\tstartToken: DiagramTokenKind,\r\n\tstopToken: DiagramTokenKind,\r\n): DiagramToken[] => {\r\n\t// If the cursor is out of bound, return an empty array\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn [];\r\n\t}\r\n\t// If the current token is not the start token, return an empty array\r\n\tif (p.tokens[p.cursorPos].kind !== startToken) {\r\n\t\treturn [];\r\n\t}\r\n\t// Consume the start token\r\n\tp.cursorPos++;\r\n\t// Does not include the start but includes the stop token\r\n\tconst tokens: DiagramToken[] = [];\r\n\r\n\t// The \"depth\" variable is useful for keeping track of the \"level\" of the tokens\r\n\tlet depth = -1;\r\n\r\n\t// The idea is to consume tokens until the depth is zero\r\n\t// To clarify, the last \"stopToken\" is included, but the first \"startToken\" is not.\r\n\tlet token: DiagramToken;\r\n\twhile (p.cursorPos < p.tokenLength) {\r\n\t\t// Consume the token from the parser and collect it to the result\r\n\t\ttoken = p.tokens[p.cursorPos];\r\n\t\tp.cursorPos++;\r\n\t\ttokens.push(token);\r\n\t\tif (token.kind === startToken) {\r\n\t\t\tdepth--;\r\n\t\t}\r\n\t\tif (token.kind === stopToken) {\r\n\t\t\tdepth++;\r\n\t\t}\r\n\t\t// The start and stop tokens are balanced\r\n\t\t// No need to continue\r\n\t\tif (depth === 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t// The cursor is pointing at the token immediately after the stop token\r\n\treturn tokens;\r\n};\r\n\r\n/**\r\n * The \"parserSkipWhiteSpace\" function skips all whitespace tokens.\r\n * It moves the cursor to the first non-whitespace token.\r\n * If the cursor is already at a non-whitespace token, the function does nothing.\r\n */\r\nconst parserSkipWhiteSpace = (\r\n\tp: Parser,\r\n): void => {\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn;\r\n\t}\r\n\t// The cursor is already pointing at a non-whitespace token\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.WHITE_SPACE\r\n\t) {\r\n\t\treturn;\r\n\t}\r\n\r\n\twhile (\r\n\t\tp.tokens[p.cursorPos].kind ===\r\n\t\tDiagramTokenKind.WHITE_SPACE\r\n\t) {\r\n\t\tp.cursorPos++;\r\n\t\tif (p.cursorPos >= p.tokenLength) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * The \"buildMissingTokenError\" function builds an \"DiagramNodeError\" object for a missing token error.\r\n * This function is called when the parser wants to report a missing token error.\r\n * More specifically, when a token is expected but not found.\r\n */\r\nconst buildMissingTokenError = (\r\n\tmarkerToken: DiagramToken,\r\n\tat: string,\r\n\tmissingToken: string,\r\n): DiagramNodeError => {\r\n\tconst { text, lineNumber, charNumber } =\r\n\t\tmarkerToken;\r\n\tconst reason = `Incomplete ${at} declaration. Missing a \"${missingToken}\" token.`;\r\n\treturn {\r\n\t\tkind: DiagramNodeKind.ERROR,\r\n\t\treason,\r\n\t\tcontext: text,\r\n\t\tcaretOffset: text.length,\r\n\t\tlineNumber,\r\n\t\tcharNumber,\r\n\t};\r\n};\r\n\r\n/**\r\n * The \"buildUnexpectedTokenError\" function builds an \"DiagramNodeError\" object for an unexpected token error.\r\n * This function is called when the parser wants to report an unexpected token error.\r\n * More specifically, when a parser expects a token but finds something else.\r\n */\r\nconst buildUnexpectedTokenError = (\r\n\tmarkerToken: DiagramToken,\r\n\terrorToken: DiagramToken,\r\n\tat: string,\r\n\texpectedToken: string,\r\n): DiagramNodeError => {\r\n\tconst { text: markerTokenText } = markerToken;\r\n\tconst {\r\n\t\ttext: errorTokenText,\r\n\t\tlineNumber,\r\n\t\tcharNumber,\r\n\t} = errorToken;\r\n\tconst reason = `Unexpected token found in ${at} declaration. Expected a \"${expectedToken}\" token but found \"${errorTokenText}\" instead.`;\r\n\treturn {\r\n\t\tkind: DiagramNodeKind.ERROR,\r\n\t\treason,\r\n\t\tcontext: `${markerTokenText} ${errorTokenText}`,\r\n\t\tcaretOffset: markerTokenText.length + 1,\r\n\t\tlineNumber,\r\n\t\tcharNumber,\r\n\t};\r\n};\r\n\r\n/**\r\n * The \"parserBuildLoopFirstNode\" function builds a \"DiagramNodeLoopFirst\" object.\r\n * It is called when the parser encounters a \"for\" or \"while\" loop declaration.\r\n * Alternatively, it returns a \"DiagramNodeError\" object if the declaration is incomplete or incorrect.\r\n */\r\nconst parserBuildLoopFirstNode = (\r\n\tp: Parser,\r\n): DiagramNodeLoopFirst | DiagramNodeError => {\r\n\t// As the parser builds the node, it collects tokens into this object\r\n\tconst node: DiagramNodeLoopFirst = {\r\n\t\tkind: DiagramNodeKind.LOOP_FIRST,\r\n\t\tbody: [],\r\n\t\tcondition: [],\r\n\t};\r\n\r\n\t// Set \"for\" or \"while\" token as marker\r\n\t// The cursor looks like this: `for ...`\r\n\t// \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t^\r\n\tlet markerToken: DiagramToken =\r\n\t\tp.tokens[p.cursorPos - 1];\r\n\r\n\t// Since syntax like \"for      (...)\"  and \"for(...)\" are both valid, skip all white spaces have to be skipped\r\n\tparserSkipWhiteSpace(p);\r\n\r\n\t// If the cursor is out of bound here, then \"(\" token is missing\r\n\t// A missing token error is reported\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-first loop\",\r\n\t\t\t\"(\",\r\n\t\t);\r\n\t}\r\n\r\n\t// If the first non-whitespace character after \"for\" or \"while\" is not \"(\" token, then it is an unexpected token error\r\n\t// A missing token error is reported\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_PAREN\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"test-first loop\",\r\n\t\t\t\"(\",\r\n\t\t);\r\n\t}\r\n\r\n\t// Both checks have passed, so set \"(\" token is the marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\t// Collect tokens between \"(\" and \")\"\r\n\tnode.condition = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_PAREN,\r\n\t\tDiagramTokenKind.RIGHT_PAREN,\r\n\t);\r\n\r\n\t// If the collected tokens has at least one element, set the last token token as marker\r\n\t// Otherwise, keep  \"(\" token as marker\r\n\t// This is done to provide accurate error messages\r\n\tif (node.condition.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tnode.condition[node.condition.length - 1];\r\n\t}\r\n\t// If the condition is empty, then the \")\" token is missing\r\n\t// It is also possible that the condition is not empty but the \")\" is not the last token\r\n\tif (\r\n\t\tnode.condition.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_PAREN\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-first loop\",\r\n\t\t\t\")\",\r\n\t\t);\r\n\t}\r\n\t// The last token in the condition is the \")\" token, consume it\r\n\tnode.condition.pop();\r\n\r\n\t// By this point, \")\" token is the marker\r\n\t// Skip all white spaces after the condition since both \"for (...){...}\" and \"for (...)               {...}\" are valid\r\n\tparserSkipWhiteSpace(p);\r\n\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\t// A missing token error is reported\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-first loop\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token but something else\r\n\t//  An unexpected token error is reported\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"test-first loop\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// Both checks have passed, set the \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\t// Collect tokens between \"{\" and \"}\"\r\n\tconst bodyTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\r\n\t// If body has at least one token, set the last token as marker .\r\n\t// Otherwise, keep \"{\" as marker\r\n\t// This is done to provide accurate error messages\r\n\tif (bodyTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyTokens[bodyTokens.length - 1];\r\n\t}\r\n\r\n\t// If the body has no token, the declaration is incomplete since the \"}\" is missing\r\n\t// It is possible that the body has tokens, but \"}\" is not the last token\r\n\t// Both of these cases are reported as missing token errors\r\n\tif (\r\n\t\tbodyTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-first loop\",\r\n\t\t\t\"}\",\r\n\t\t);\r\n\t}\r\n\t// The last token in the body is the \"}\" token, consume it\r\n\tbodyTokens.pop();\r\n\r\n\t// Only parse the body after the declaration is valid\r\n\tnode.body = parserGetAllNodes(\r\n\t\tparserInit(bodyTokens),\r\n\t);\r\n\treturn node;\r\n};\r\n\r\n/**\r\n * The \"parserBuildLoopLastNode\" function builds a \"DiagramNodeLoopLast\" object.\r\n * It is called when the parser encounters a \"do-while\" loop declaration.\r\n * It returns a \"DiagramNodeError\" object if the declaration is incomplete or incorrect.\r\n */\r\nconst parserBuildLoopLastNode = (\r\n\tp: Parser,\r\n): DiagramNodeLoopLast | DiagramNodeError => {\r\n\tconst node: DiagramNodeLoopLast = {\r\n\t\tkind: DiagramNodeKind.LOOP_LAST,\r\n\t\tbody: [],\r\n\t\tcondition: [],\r\n\t};\r\n\r\n\t// Set \"do\" token as marker\r\n\tlet markerToken = p.tokens[p.cursorPos - 1];\r\n\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\r\n\t// If body has at least one token,\r\n\t// set the last token as marker and consume it.\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyTokens[bodyTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"}\",\r\n\t\t);\r\n\t}\r\n\t// Consume the \"}\" token in body\r\n\tbodyTokens.pop();\r\n\t// By this point, the marker is \"}\" token\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"while\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"while\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found after \"}\" is not a \"while\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.KEYWORD ||\r\n\t\tp.tokens[p.cursorPos].text !== \"while\"\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"while\",\r\n\t\t);\r\n\t}\r\n\t// Set \"while\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\t// Consume \"while token\"\r\n\tp.cursorPos++;\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"(\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"(\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found is not a \"(\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_PAREN\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\"(\",\r\n\t\t);\r\n\t}\r\n\t// Set \"(\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tnode.condition = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_PAREN,\r\n\t\tDiagramTokenKind.RIGHT_PAREN,\r\n\t);\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"(\" token as marker\r\n\tif (node.condition.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tnode.condition[node.condition.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \")\" token is missing\r\n\t// Or the condition is not empty but \")\" is not found\r\n\tif (\r\n\t\tnode.condition.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_PAREN\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\")\",\r\n\t\t);\r\n\t}\r\n\t// Consume \")\" token from condition\r\n\tnode.condition.pop();\r\n\t// At this point, \")\" is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \";\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\";\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found after \")\" is not a \";\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.SEMICOLON\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"test-last loop\",\r\n\t\t\t\";\",\r\n\t\t);\r\n\t}\r\n\t// Consume semicolon token\r\n\tp.cursorPos++;\r\n\r\n\t// Only build the body nodes if the parent declaration is correct\r\n\tnode.body = parserGetAllNodes(\r\n\t\tparserInit(bodyTokens),\r\n\t);\r\n\treturn node;\r\n};\r\n\r\n/**\r\n * The \"parserBuildIfElseNode\" function builds a \"DiagramNodeIfElse\" object.\r\n * It is called when the parser encounters an \"if\" or \"if-else\" block declaration.\r\n * It returns a \"DiagramNodeError\" object if the declaration is incomplete or incorrect.\r\n */\r\nconst parserBuildIfElseNode = (\r\n\tp: Parser,\r\n): DiagramNodeIfElse | DiagramNodeError => {\r\n\tconst node: DiagramNodeIfElse = {\r\n\t\tkind: DiagramNodeKind.IF_ELSE,\r\n\t\tcondition: [],\r\n\t\tbodyIf: [],\r\n\t\tbodyElse: [],\r\n\t};\r\n\t// Set \"for\" token as marker\r\n\tlet markerToken: DiagramToken =\r\n\t\tp.tokens[p.cursorPos - 1];\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"(\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"branching block (if)\",\r\n\t\t\t\"(\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found is not a \"(\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_PAREN\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"branching block (if)\",\r\n\t\t\t\"(\",\r\n\t\t);\r\n\t}\r\n\t// Set \"(\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\tnode.condition = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_PAREN,\r\n\t\tDiagramTokenKind.RIGHT_PAREN,\r\n\t);\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"(\" token as marker\r\n\tif (node.condition.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tnode.condition[node.condition.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \")\" token is missing\r\n\t// Or the condition is not empty but \")\" is not found\r\n\tif (\r\n\t\tnode.condition.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_PAREN\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"branching block (if)\",\r\n\t\t\t\")\",\r\n\t\t);\r\n\t}\r\n\t// Consume \")\" token from condition\r\n\tnode.condition.pop();\r\n\t// By this point, \")\" token is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"branching block (if)\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"branching block (if)\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyIfTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\t// If body has at least one token,\r\n\t// set the last token as marker .\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyIfTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyIfTokens[bodyIfTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyIfTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"branching block (if)\",\r\n\t\t\t\"}\",\r\n\t\t);\r\n\t}\r\n\t// Consume \"}\" token from body\r\n\tbodyIfTokens.pop();\r\n\t// Only parse the body after the declaration is valid\r\n\t// the body of if branch has to be parsed here\r\n\t// before possible return\r\n\tnode.bodyIf = parserGetAllNodes(\r\n\t\tparserInit(bodyIfTokens),\r\n\t);\r\n\tparserSkipWhiteSpace(p);\r\n\r\n\t// Since the else branch is optional, the parser has to check if it exists\r\n\t// If the cursor is out of bound, \"else\" token is missing\r\n\t// This is also the end of the \"if\" block\r\n\tif (\r\n\t\tp.cursorPos >= p.tokenLength ||\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.KEYWORD ||\r\n\t\tp.tokens[p.cursorPos].text !== \"else\"\r\n\t) {\r\n\t\treturn node;\r\n\t}\r\n\t// The cursor is pointing at \"else\" token\r\n\t// Set \"else\" as marker and consume it\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\tp.cursorPos++;\r\n\t// By this point, \"else\" is the marker\r\n\tparserSkipWhiteSpace(p);\r\n\t// If the cursor is out of bound, \"{\" token is missing\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"branching block (if-else)\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// The first non-whitespace found is not a \"{\" token\r\n\t// but something else\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\treturn buildUnexpectedTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\tp.tokens[p.cursorPos],\r\n\t\t\t\"branching block (if-else)\",\r\n\t\t\t\"{\",\r\n\t\t);\r\n\t}\r\n\t// Set \"{\" token as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\tconst bodyElseTokens =\r\n\t\tparserCollectTokensBetween(\r\n\t\t\tp,\r\n\t\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t\t);\r\n\t// If body has at least one token,\r\n\t// set the last token as marker .\r\n\t// If body has no token, keep \"{\" as marker\r\n\tif (bodyElseTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyElseTokens[bodyElseTokens.length - 1];\r\n\t}\r\n\t// If the body has no token, the declaration is incomplete\r\n\t// Or the body has tokens, but \"}\" is not found\r\n\tif (\r\n\t\tbodyElseTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"branching block (if-else)\",\r\n\t\t\t\"}\",\r\n\t\t);\r\n\t}\r\n\t// Consume \"}\" token from body\r\n\tbodyElseTokens.pop();\r\n\r\n\tnode.bodyElse = parserGetAllNodes(\r\n\t\tparserInit(bodyElseTokens),\r\n\t);\r\n\r\n\treturn node;\r\n};\r\n\r\n/**\r\n * The \"parserGetNextNodeThenAdvance\" function returns the next node from the parser.\r\n * It also advances the cursor position to the next token.\r\n */\r\nconst parserGetNextNode = (\r\n\tp: Parser,\r\n): DiagramNode => {\r\n\t// Skip all leading \"DiagramToken\" objects with \"DiagramTokenKind.WHITE_SPACE\" kind\r\n\tparserSkipWhiteSpace(p);\r\n\r\n\t// If the cursor is out of bound, return the end node\r\n\tif (p.cursorPos >= p.tokenLength) {\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.END,\r\n\t\t};\r\n\t}\r\n\r\n\t// The cursor is pointing at a non-whitespace token\r\n\t// consume it\r\n\tconst token = p.tokens[p.cursorPos];\r\n\tp.cursorPos++;\r\n\r\n\t// If the token is a keyword, build a node based on the keyword\r\n\tif (token.kind === DiagramTokenKind.KEYWORD) {\r\n\t\tswitch (token.text) {\r\n\t\t\tcase \"for\":\r\n\t\t\tcase \"while\":\r\n\t\t\t\treturn parserBuildLoopFirstNode(p);\r\n\t\t\tcase \"do\":\r\n\t\t\t\treturn parserBuildLoopLastNode(p);\r\n\t\t\tcase \"if\":\r\n\t\t\t\treturn parserBuildIfElseNode(p);\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t// If it is not a keyword, it is assumed to be a process or a function\r\n\t// The \"tokens\" array collects the body of the process or the declaration of the function\r\n\t// This is a violation of the \"single responsibility principle\" if I have ever seen one\r\n\tconst tokens: DiagramToken[] = [token];\r\n\r\n\tlet markerToken = token;\r\n\r\n\t// If the current token is a semicolon, then it is a process with no body\r\n\t// For now, this is allowed much like \";\" empty statement in C\r\n\tif (\r\n\t\tmarkerToken.kind ===\r\n\t\tDiagramTokenKind.SEMICOLON\r\n\t) {\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.PROCESS,\r\n\t\t\tbody: [],\r\n\t\t};\r\n\t}\r\n\r\n\t// Collect tokens until a semicolon or a left curly brace is found\r\n\twhile (\r\n\t\tp.cursorPos < p.tokenLength &&\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.SEMICOLON &&\r\n\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.LEFT_CURLY\r\n\t) {\r\n\t\tmarkerToken = p.tokens[p.cursorPos];\r\n\t\ttokens.push(p.tokens[p.cursorPos]);\r\n\t\tp.cursorPos++;\r\n\t}\r\n\r\n\t// It is possible that neither \";\" or \"{\" token is found\r\n\t// The loop terminates becaues it reached the end of the tokens\r\n\t// In this case, the process is incomplete and a missing token error is reported\r\n\tif (\r\n\t\tp.cursorPos >= p.tokenLength ||\r\n\t\t(p.tokens[p.cursorPos].kind !==\r\n\t\t\tDiagramTokenKind.LEFT_CURLY &&\r\n\t\t\tp.tokens[p.cursorPos].kind !==\r\n\t\t\t\tDiagramTokenKind.SEMICOLON)\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"process\",\r\n\t\t\t\";\",\r\n\t\t);\r\n\t}\r\n\r\n\t// If the loop stopped because it encountered a \";\" token, return a process node with the collected tokens\r\n\tif (\r\n\t\tp.tokens[p.cursorPos].kind ===\r\n\t\tDiagramTokenKind.SEMICOLON\r\n\t) {\r\n\t\t// Also consume the \";\" token\r\n\t\tp.cursorPos++;\r\n\t\treturn {\r\n\t\t\tkind: DiagramNodeKind.PROCESS,\r\n\t\t\tbody: tokens,\r\n\t\t};\r\n\t}\r\n\r\n\t// By this point, the loop stopped because it encountered a \"{\" token\r\n\t// Set it as marker\r\n\tmarkerToken = p.tokens[p.cursorPos];\r\n\r\n\t// Collect tokens between \"{\" and \"}\"\r\n\tconst bodyTokens = parserCollectTokensBetween(\r\n\t\tp,\r\n\t\tDiagramTokenKind.LEFT_CURLY,\r\n\t\tDiagramTokenKind.RIGHT_CURLY,\r\n\t);\r\n\r\n\t// If the condition has at least one element,\r\n\t// set the last token token as marker\r\n\t// Otherwise, keep  \"{\" token as marker\r\n\tif (bodyTokens.length > 0) {\r\n\t\tmarkerToken =\r\n\t\t\tbodyTokens[bodyTokens.length - 1];\r\n\t}\r\n\t// If the condition is empty, the \"}\" token is missing\r\n\t// It is possible the condition is not empty but \"}\" is not last token\r\n\t// Both of these cases are reported as missing token errors\r\n\tif (\r\n\t\tbodyTokens.length === 0 ||\r\n\t\tmarkerToken.kind !==\r\n\t\t\tDiagramTokenKind.RIGHT_CURLY\r\n\t) {\r\n\t\treturn buildMissingTokenError(\r\n\t\t\tmarkerToken,\r\n\t\t\t\"function\",\r\n\t\t\t\"}\",\r\n\t\t);\r\n\t}\r\n\t// The check has passed, consume the \"}\" token from body\r\n\tbodyTokens.pop();\r\n\r\n\t// Parse the body of the function after the declaration is valid\r\n\treturn {\r\n\t\tkind: DiagramNodeKind.FUNCTION,\r\n\t\tdeclaration: tokens,\r\n\t\tbody: parserGetAllNodes(\r\n\t\t\tparserInit(bodyTokens),\r\n\t\t),\r\n\t};\r\n};\r\n\r\n/**\r\n * The \"parserGetAllNodes\" function parses all \"DiagramToken\" from objects.\r\n */\r\nexport const parserGetAllNodes = (\r\n\tp: Parser,\r\n): DiagramNode[] => {\r\n\tconst nodes: DiagramNode[] = [];\r\n\tlet node: DiagramNode;\r\n\r\n\t// The loop stops when it encounters an \"END\" or an \"ERROR\" node\r\n\twhile (\r\n\t\t(node = parserGetNextNode(p)).kind !==\r\n\t\tDiagramNodeKind.END\r\n\t) {\r\n\t\tnodes.push(node);\r\n\t\tif (node.kind === DiagramNodeKind.ERROR) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn nodes;\r\n};\r\n","import { FC } from \"react\";\r\nimport {\r\n\tSvgIconProps,\r\n\tSvgIcon,\r\n} from \"@mui/material\";\r\n\r\nexport const ArrowTopLeftBottomRight: FC<\r\n\tSvgIconProps\r\n> = (props) => {\r\n\tconst { sx } = props;\r\n\r\n\treturn (\r\n\t\t<SvgIcon\r\n\t\t\tsx={{\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\twidth: \"100%\",\r\n\t\t\t\theight: \"100%\",\r\n\t\t\t\t...sx,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t<svg\r\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\tpreserveAspectRatio=\"none\"\r\n\t\t\t\tfill=\"none\"\r\n\t\t\t\tviewBox=\"0 0 5 5\"\r\n\t\t\t\tstrokeWidth=\"0.1\"\r\n\t\t\t>\r\n\t\t\t\t<line\r\n\t\t\t\t\tx1=\"0\"\r\n\t\t\t\t\ty1=\"0\"\r\n\t\t\t\t\tx2=\"5\"\r\n\t\t\t\t\ty2=\"5\"\r\n\t\t\t\t\tstroke=\"currentColor\"\r\n\t\t\t\t\tstrokeLinecap=\"round\"\r\n\t\t\t\t/>\r\n\t\t\t</svg>\r\n\t\t</SvgIcon>\r\n\t);\r\n};\r\n","import { FC } from \"react\";\r\nimport {\r\n\tSvgIconProps,\r\n\tSvgIcon,\r\n} from \"@mui/material\";\r\n\r\nexport const ArrowBottomLeftTopRight: FC<\r\n\tSvgIconProps\r\n> = (props) => {\r\n\tconst { sx } = props;\r\n\r\n\treturn (\r\n\t\t<SvgIcon\r\n\t\t\tsx={{\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\twidth: \"100%\",\r\n\t\t\t\theight: \"100%\",\r\n\t\t\t\t...sx,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t<svg\r\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\tpreserveAspectRatio=\"none\"\r\n\t\t\t\tfill=\"none\"\r\n\t\t\t\tviewBox=\"0 0 5 5\"\r\n\t\t\t\tstrokeWidth=\"0.1\"\r\n\t\t\t>\r\n\t\t\t\t<line\r\n\t\t\t\t\tx1=\"0\"\r\n\t\t\t\t\ty1=\"5\"\r\n\t\t\t\t\tx2=\"5\"\r\n\t\t\t\t\ty2=\"0\"\r\n\t\t\t\t\tstroke=\"currentColor\"\r\n\t\t\t\t\tstrokeLinecap=\"round\"\r\n\t\t\t\t/>\r\n\t\t\t</svg>\r\n\t\t</SvgIcon>\r\n\t);\r\n};\r\n","import { FC, Fragment, ReactNode } from \"react\";\r\nimport {\r\n\tBox,\r\n\tGrid,\r\n\tTypographyProps,\r\n\tTypography,\r\n\tStack,\r\n} from \"@mui/material\";\r\nimport { grey } from \"@mui/material/colors\";\r\n\r\nimport { ArrowTopLeftBottomRight } from \"./ArrowTopLeftBottomRight\";\r\nimport { ArrowBottomLeftTopRight } from \"./ArrowBottomLeftTopRight\";\r\nimport {\r\n\tDiagramNode,\r\n\tDiagramNodeKind,\r\n\tDiagramToken,\r\n} from \"core\";\r\n\r\ntype DiagramWrapperProps = {\r\n\tchildren: ReactNode | ReactNode[];\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramWrapper: FC<DiagramWrapperProps> = (\r\n\tprops,\r\n) => {\r\n\tconst {\r\n\t\tchildren,\r\n\t\tborderTop,\r\n\t\tborderBottom,\r\n\t\tborderLeft,\r\n\t\tborderRight,\r\n\t} = props;\r\n\treturn (\r\n\t\t<Box\r\n\t\t\tsx={{\r\n\t\t\t\tborderStyle: \"solid\",\r\n\t\t\t\tborderLeftWidth: borderLeft ? 2 : 0,\r\n\t\t\t\tborderTopWidth: borderTop ? 2 : 0,\r\n\t\t\t\tborderBottomWidth: borderBottom ? 2 : 0,\r\n\t\t\t\tborderRightWidth: borderRight ? 2 : 0,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{children}\r\n\t\t</Box>\r\n\t);\r\n};\r\n\r\ntype DiagramComponentTextProps =\r\n\tTypographyProps & {\r\n\t\tchildren?: string;\r\n\t};\r\nconst DiagramComponentText: FC<\r\n\tDiagramComponentTextProps\r\n> = (props) => {\r\n\tconst { children, ...rest } = props;\r\n\r\n\treturn (\r\n\t\t<Typography\r\n\t\t\tpadding={1.5}\r\n\t\t\t{...rest}\r\n\t\t\tsx={{\r\n\t\t\t\tfontFamily: \"Fira Code\",\r\n\t\t\t\twordBreak: \"break-word\",\r\n\t\t\t\tfontVariantLigatures: \"contextual\",\r\n\t\t\t\t...rest.sx,\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{children ?? \"-\"}\r\n\t\t</Typography>\r\n\t);\r\n};\r\n\r\ntype DiagramProcessProps = {\r\n\tbodyTokens?: DiagramToken[];\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramProcess: FC<DiagramProcessProps> = (\r\n\tprops,\r\n) => {\r\n\tconst { bodyTokens, ...rest } = props;\r\n\r\n\tlet bodyText: string | undefined = undefined;\r\n\tif (bodyTokens !== undefined) {\r\n\t\tbodyText = bodyTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t\tif (bodyText.length === 0) {\r\n\t\t\tbodyText = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{bodyText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramLoopFirstProps = {\r\n\tconditionTokens?: DiagramToken[];\r\n\tbody: DiagramNode[];\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const DiagramLoopFirst: FC<\r\n\tDiagramLoopFirstProps\r\n> = (props) => {\r\n\tconst { conditionTokens, body, ...rest } =\r\n\t\tprops;\r\n\r\n\tlet conditionText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tconditionTokens !== undefined &&\r\n\t\tconditionTokens.length > 0\r\n\t) {\r\n\t\tconditionText = conditionTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\tlet bodyNode: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess\r\n\t\t\tborderTop\r\n\t\t\tborderLeft\r\n\t\t/>\r\n\t);\r\n\tif (body.length > 0) {\r\n\t\tbodyNode = body.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`subnode-${index}`}\r\n\t\t\t\tborderTop\r\n\t\t\t\tborderLeft\r\n\t\t\t\tnode={subnode}\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{conditionText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<Box paddingLeft={2}>{bodyNode}</Box>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramLoopLastProps = {\r\n\tconditionTokens?: DiagramToken[];\r\n\tbody: DiagramNode[];\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const DiagramLoopLast: FC<\r\n\tDiagramLoopLastProps\r\n> = (props) => {\r\n\tconst { conditionTokens, body, ...rest } =\r\n\t\tprops;\r\n\r\n\tlet conditionText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tconditionTokens !== undefined &&\r\n\t\tconditionTokens.length > 0\r\n\t) {\r\n\t\tconditionText = conditionTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNode: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess\r\n\t\t\tborderBottom\r\n\t\t\tborderLeft\r\n\t\t/>\r\n\t);\r\n\tif (body.length > 0) {\r\n\t\tbodyNode = body.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`subnode-${index}`}\r\n\t\t\t\tnode={subnode}\r\n\t\t\t\tborderBottom\r\n\t\t\t\tborderLeft\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<Box paddingLeft={2}>{bodyNode}</Box>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{conditionText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramIfElseProps = {\r\n\tconditionTokens?: DiagramToken[];\r\n\tbodyIf: DiagramNode[];\r\n\tbodyElse: DiagramNode[];\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const DiagramIfElse: FC<\r\n\tDiagramIfElseProps\r\n> = (props) => {\r\n\tconst {\r\n\t\tconditionTokens,\r\n\t\tbodyIf,\r\n\t\tbodyElse,\r\n\t\t...rest\r\n\t} = props;\r\n\r\n\tlet conditionText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tconditionTokens !== undefined &&\r\n\t\tconditionTokens.length > 0\r\n\t) {\r\n\t\tconditionText = conditionTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNodeIf: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess borderTop />\r\n\t);\r\n\tif (bodyIf.length > 0) {\r\n\t\tbodyNodeIf = bodyIf.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`index-${index}`}\r\n\t\t\t\tborderTop\r\n\t\t\t\tnode={subnode}\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\tlet bodyNodeElse: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess borderTop />\r\n\t);\r\n\tif (bodyElse.length > 0) {\r\n\t\tbodyNodeElse = bodyElse.map(\r\n\t\t\t(subnode, index) => (\r\n\t\t\t\t<Diagram\r\n\t\t\t\t\tkey={`index-${index}`}\r\n\t\t\t\t\tborderTop\r\n\t\t\t\t\tnode={subnode}\r\n\t\t\t\t/>\r\n\t\t\t),\r\n\t\t);\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<Grid\r\n\t\t\t\tcontainer\r\n\t\t\t\theight=\"100%\"\r\n\t\t\t>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={12}\r\n\t\t\t\t>\r\n\t\t\t\t\t<DiagramComponentText align=\"center\">\r\n\t\t\t\t\t\t{conditionText}\r\n\t\t\t\t\t</DiagramComponentText>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Box\r\n\t\t\t\t\t\theight=\"100%\"\r\n\t\t\t\t\t\tdisplay=\"flex\"\r\n\t\t\t\t\t\talignItems=\"center\"\r\n\t\t\t\t\t\tjustifyContent=\"center\"\r\n\t\t\t\t\t\tposition=\"relative\"\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<DiagramComponentText\r\n\t\t\t\t\t\t\tsx={{\r\n\t\t\t\t\t\t\t\tzIndex: 2,\r\n\t\t\t\t\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tTrue\r\n\t\t\t\t\t\t</DiagramComponentText>\r\n\t\t\t\t\t\t<ArrowTopLeftBottomRight htmlColor=\"black\" />\r\n\t\t\t\t\t</Box>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Box\r\n\t\t\t\t\t\theight=\"100%\"\r\n\t\t\t\t\t\tdisplay=\"flex\"\r\n\t\t\t\t\t\talignItems=\"center\"\r\n\t\t\t\t\t\tjustifyContent=\"center\"\r\n\t\t\t\t\t\tposition=\"relative\"\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<ArrowBottomLeftTopRight />\r\n\t\t\t\t\t\t<DiagramComponentText\r\n\t\t\t\t\t\t\tsx={{\r\n\t\t\t\t\t\t\t\tzIndex: 2,\r\n\t\t\t\t\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tFalse\r\n\t\t\t\t\t\t</DiagramComponentText>\r\n\t\t\t\t\t</Box>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Stack\r\n\t\t\t\t\t\theight=\"100%\"\r\n\t\t\t\t\t\tsx={{\r\n\t\t\t\t\t\t\tborderColor: \"inherit\",\r\n\t\t\t\t\t\t\tborderRightStyle: \"solid\",\r\n\t\t\t\t\t\t\tborderRightWidth: 2,\r\n\t\t\t\t\t\t}}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t{bodyNodeIf}\r\n\t\t\t\t\t</Stack>\r\n\t\t\t\t</Grid>\r\n\t\t\t\t<Grid\r\n\t\t\t\t\titem\r\n\t\t\t\t\txs={6}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Stack height=\"100%\">\r\n\t\t\t\t\t\t{bodyNodeElse}\r\n\t\t\t\t\t</Stack>\r\n\t\t\t\t</Grid>\r\n\t\t\t</Grid>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramFuncProps = {\r\n\tdeclarationTokens: DiagramToken[];\r\n\tbody: DiagramNode[];\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramFunc: FC<DiagramFuncProps> = (\r\n\tprops,\r\n) => {\r\n\tconst { declarationTokens, body, ...rest } =\r\n\t\tprops;\r\n\r\n\tlet declarationText: string | undefined =\r\n\t\tundefined;\r\n\tif (\r\n\t\tdeclarationTokens !== undefined &&\r\n\t\tdeclarationTokens.length > 0\r\n\t) {\r\n\t\tdeclarationText = declarationTokens\r\n\t\t\t.map((token) => token.text)\r\n\t\t\t.join(\"\")\r\n\t\t\t.trim();\r\n\t}\r\n\r\n\tlet bodyNode: ReactNode | ReactNode[] = (\r\n\t\t<DiagramProcess\r\n\t\t\tborderTop\r\n\t\t\tborderLeft\r\n\t\t\tborderRight\r\n\t\t/>\r\n\t);\r\n\tif (body.length > 0) {\r\n\t\tbodyNode = body.map((subnode, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`subnode-${index}`}\r\n\t\t\t\tnode={subnode}\r\n\t\t\t\tborderTop\r\n\t\t\t\tborderLeft\r\n\t\t\t\tborderRight\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText align=\"center\">\r\n\t\t\t\t{declarationText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<Box paddingX={2}>{bodyNode}</Box>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramErrorProps = {\r\n\tcontext: string;\r\n\treason: string;\r\n\tlineNumber: number;\r\n\tcharNumber: number;\r\n\tcaretOffset: number;\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nconst DiagramError: FC<DiagramErrorProps> = (\r\n\tprops,\r\n) => {\r\n\tconst {\r\n\t\tcontext,\r\n\t\treason,\r\n\t\tlineNumber,\r\n\t\tcharNumber,\r\n\t\tcaretOffset,\r\n\r\n\t\t...rest\r\n\t} = props;\r\n\tconst errorText = `At line ${lineNumber}, character ${charNumber}: ${reason}`;\r\n\tconst caretText = \"~\".repeat(caretOffset) + \"^\";\r\n\r\n\treturn (\r\n\t\t<DiagramWrapper {...rest}>\r\n\t\t\t<DiagramComponentText>\r\n\t\t\t\t{errorText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<DiagramComponentText paddingY={0}>\r\n\t\t\t\t{context}\r\n\t\t\t</DiagramComponentText>\r\n\t\t\t<DiagramComponentText paddingY={0}>\r\n\t\t\t\t{caretText}\r\n\t\t\t</DiagramComponentText>\r\n\t\t</DiagramWrapper>\r\n\t);\r\n};\r\n\r\ntype DiagramProps = {\r\n\tnode: DiagramNode;\r\n\r\n\tborderTop?: boolean;\r\n\tborderBottom?: boolean;\r\n\tborderRight?: boolean;\r\n\tborderLeft?: boolean;\r\n};\r\nexport const Diagram: FC<DiagramProps> = (\r\n\tprops,\r\n) => {\r\n\tconst { node, ...rest } = props;\r\n\r\n\tswitch (node.kind) {\r\n\t\tcase DiagramNodeKind.ERROR:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramError\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tcaretOffset={node.caretOffset}\r\n\t\t\t\t\tcontext={node.context}\r\n\t\t\t\t\treason={node.reason}\r\n\t\t\t\t\tlineNumber={node.lineNumber}\r\n\t\t\t\t\tcharNumber={node.charNumber}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.FUNCTION:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramFunc\r\n\t\t\t\t\tdeclarationTokens={node.declaration}\r\n\t\t\t\t\tbody={node.body}\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.LOOP_FIRST:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramLoopFirst\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tconditionTokens={node.condition}\r\n\t\t\t\t\tbody={node.body}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.LOOP_LAST:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramLoopLast\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tconditionTokens={node.condition}\r\n\t\t\t\t\tbody={node.body}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.IF_ELSE:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramIfElse\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tconditionTokens={node.condition}\r\n\t\t\t\t\tbodyIf={node.bodyIf}\r\n\t\t\t\t\tbodyElse={node.bodyElse}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\tcase DiagramNodeKind.PROCESS:\r\n\t\t\treturn (\r\n\t\t\t\t<DiagramProcess\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tbodyTokens={node.body}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t}\r\n\treturn <Fragment />;\r\n};\r\n","import { FC, ReactNode } from \"react\";\r\n\r\nimport {\r\n\tBox,\r\n\tSxProps,\r\n\tTypography,\r\n} from \"@mui/material\";\r\nimport { grey } from \"@mui/material/colors\";\r\n\r\nimport { DiagramNode } from \"core\";\r\nimport { Diagram } from \"App/components/Diagram/Diagram\";\r\n\r\n/**\r\n * This component is a preview of the diagram.\r\n * It prepares the root-level nodes and recursively renders their children.\r\n */\r\ntype DiagramPreviewProps = {\r\n\tnodes: DiagramNode[];\r\n\tid: string;\r\n\tboxProps: SxProps;\r\n};\r\nexport const DiagramPreview: FC<\r\n\tDiagramPreviewProps\r\n> = (props): ReactNode => {\r\n\tconst { nodes, id, boxProps } = props;\r\n\r\n\t// Empty state of the preview\r\n\tlet component: ReactNode | ReactNode[] = (\r\n\t\t<Typography\r\n\t\t\tfontFamily=\"Fira Code\"\r\n\t\t\tfontStyle=\"italic\"\r\n\t\t>\r\n\t\t\tNothing to display.\r\n\t\t</Typography>\r\n\t);\r\n\t// If there are nodes, render them\r\n\tif (nodes.length > 0) {\r\n\t\tcomponent = nodes.map((node, index) => (\r\n\t\t\t<Diagram\r\n\t\t\t\tkey={`top-level-node-${index}`}\r\n\t\t\t\tnode={node}\r\n\t\t\t\tborderLeft\r\n\t\t\t\tborderTop\r\n\t\t\t\tborderRight\r\n\t\t\t\tborderBottom={index === nodes.length - 1}\r\n\t\t\t/>\r\n\t\t));\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Box\r\n\t\t\tsx={{\r\n\t\t\t\t...boxProps,\r\n\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\tborderColor: grey[700],\r\n\t\t\t\theight: \"100%\",\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t<Box\r\n\t\t\t\tid={id}\r\n\t\t\t\tsx={{\r\n\t\t\t\t\tmaxWidth: \"640px\",\r\n\t\t\t\t\tbackgroundColor: grey[300],\r\n\t\t\t\t\tborderColor: grey[700],\r\n\t\t\t\t}}\r\n\t\t\t>\r\n\t\t\t\t{component}\r\n\t\t\t</Box>\r\n\t\t</Box>\r\n\t);\r\n};\r\n","import { FC } from \"react\";\r\n\r\nimport ReactCodeMirror, {\r\n\tEditorView,\r\n} from \"@uiw/react-codemirror\";\r\n\r\nimport \"./styles.css\";\r\n\r\n/**\r\n * This component is a styled code editor.\r\n * It uses the \"react-codemirror\" library.\r\n */\r\ntype StyledCodeEditorProps = {\r\n\tvalue: string;\r\n\tonValueChange: (value: string) => void;\r\n};\r\nexport const StyledCodeEditor: FC<\r\n\tStyledCodeEditorProps\r\n> = (props) => {\r\n\tconst { value, onValueChange } = props;\r\n\r\n\treturn (\r\n\t\t<ReactCodeMirror\r\n\t\t\tvalue={value}\r\n\t\t\tonChange={onValueChange}\r\n\t\t\ttheme=\"dark\"\r\n\t\t\textensions={[EditorView.lineWrapping]}\r\n\t\t/>\r\n\t);\r\n};\r\n","import { FC } from \"react\";\r\nimport {\r\n\tButton,\r\n\tButtonProps,\r\n\tTooltip,\r\n} from \"@mui/material\";\r\n\r\n/**\r\n * This component is a button that adapts to the screen size.\r\n * When the screen size is small, the label collapses down to an icon.\r\n */\r\ntype AdaptiveButtonProps = ButtonProps & {\r\n\tcollapsed: boolean;\r\n};\r\nexport const AdaptiveButton: FC<\r\n\tAdaptiveButtonProps\r\n> = (props) => {\r\n\tconst { collapsed, ...rest } = props;\r\n\r\n\tif (collapsed) {\r\n\t\treturn (\r\n\t\t\t<Tooltip title={rest.children}>\r\n\t\t\t\t<Button\r\n\t\t\t\t\t{...rest}\r\n\t\t\t\t\tstartIcon={undefined}\r\n\t\t\t\t\tendIcon={undefined}\r\n\t\t\t\t>\r\n\t\t\t\t\t{rest.startIcon}\r\n\t\t\t\t\t{rest.endIcon}\r\n\t\t\t\t</Button>\r\n\t\t\t</Tooltip>\r\n\t\t);\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Button\r\n\t\t\t{...rest}\r\n\t\t\tstartIcon={rest.startIcon}\r\n\t\t\tendIcon={rest.endIcon}\r\n\t\t>\r\n\t\t\t{rest.children}\r\n\t\t</Button>\r\n\t);\r\n};\r\n","import {\r\n\tFC,\r\n\tReactNode,\r\n\tuseEffect,\r\n\tuseRef,\r\n\tuseState,\r\n} from \"react\";\r\nimport {\r\n\tBox,\r\n\tGrid,\r\n\tStack,\r\n\tPaper,\r\n\tButton,\r\n\tuseMediaQuery,\r\n\tTheme,\r\n\tButtonGroup,\r\n} from \"@mui/material\";\r\nimport { getPreviewState } from \"App/components/LiveEditor/helper\";\r\nimport { LaunchRounded } from \"@mui/icons-material\";\r\n\r\n/**\r\n * This component defines the layout and its behavior for the \"LiveEditor\" component.\r\n *\r\n * There are behaviors for different screen sizes.\r\n * At small screen sizes, both panels are not displayed side by side.\r\n * Instead, a panel takes up the entire screen and the other panel is hidden.\r\n * At medium and large screen sizes, the both panels are displayed side by side.\r\n */\r\ntype LayoutProps = {\r\n\tslotAppBar: ReactNode;\r\n\tslotPanelLeft: ReactNode;\r\n\tslotPanelRight: ReactNode;\r\n};\r\nexport const Layout: FC<LayoutProps> = (\r\n\tprops,\r\n) => {\r\n\tconst {\r\n\t\tslotAppBar,\r\n\t\tslotPanelLeft,\r\n\t\tslotPanelRight,\r\n\t} = props;\r\n\r\n\t// Prepare the app bar reference\r\n\tconst appBarRef = useRef<HTMLDivElement | null>(\r\n\t\tnull,\r\n\t);\r\n\r\n\t// Prepare the app bar static height\r\n\t// This is used to calculate the height of the left and right panels in the layout\r\n\t// Without a fixed height, the panels have unpredictable behavior\r\n\tconst [\r\n\t\tappBarStaticHeight,\r\n\t\tsetAppBarStaticHeight,\r\n\t] = useState(0);\r\n\r\n\t// The left panel can be hidden or shown\r\n\t// The initial state is determined by the query parameter in the URL\r\n\tconst [leftPanelOpen, setLeftPanelOpen] =\r\n\t\tuseState(\r\n\t\t\tgetPreviewState(window.location.href),\r\n\t\t);\r\n\r\n\t// Fires when the \"Show Code\" and \"Hide Code\" button is clicked\r\n\tconst handlePreviewToggle = () => {\r\n\t\tsetLeftPanelOpen((prev) => !prev);\r\n\t};\r\n\r\n\t// The breakpoint for the extra small screen\r\n\tconst matchBreakpointXs = useMediaQuery<Theme>(\r\n\t\t(theme) => theme.breakpoints.down(\"md\"),\r\n\t);\r\n\r\n\t// Set the app bar static height, but only after the app bar ready\r\n\tuseEffect(() => {\r\n\t\tif (appBarRef.current === null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsetAppBarStaticHeight(\r\n\t\t\tappBarRef.current.getBoundingClientRect()\r\n\t\t\t\t.height,\r\n\t\t);\r\n\t}, [appBarRef]);\r\n\r\n\treturn (\r\n\t\t<Box>\r\n\t\t\t<Paper\r\n\t\t\t\tref={appBarRef}\r\n\t\t\t\tsquare\r\n\t\t\t\televation={0}\r\n\t\t\t\tsx={{\r\n\t\t\t\t\tpadding: 1,\r\n\t\t\t\t}}\r\n\t\t\t>\r\n\t\t\t\t<Stack\r\n\t\t\t\t\tdisplay=\"flex\"\r\n\t\t\t\t\tdirection=\"row\"\r\n\t\t\t\t\tjustifyContent=\"space-between\"\r\n\t\t\t\t>\r\n\t\t\t\t\t<ButtonGroup variant=\"outlined\">\r\n\t\t\t\t\t\t<Button onClick={handlePreviewToggle}>\r\n\t\t\t\t\t\t\t{leftPanelOpen\r\n\t\t\t\t\t\t\t\t? \"Show code\"\r\n\t\t\t\t\t\t\t\t: \"Hide code\"}\r\n\t\t\t\t\t\t</Button>{\" \"}\r\n\t\t\t\t\t\t<Button\r\n\t\t\t\t\t\t\thref=\"https://eurydia.github.io/project-nassi-shneiderman-diagram-builder-online-docs/\"\r\n\t\t\t\t\t\t\tcomponent=\"a\"\r\n\t\t\t\t\t\t\ttarget=\"_blank\"\r\n\t\t\t\t\t\t\tendIcon={<LaunchRounded />}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tdocs\r\n\t\t\t\t\t\t</Button>\r\n\t\t\t\t\t</ButtonGroup>\r\n\t\t\t\t\t{slotAppBar}\r\n\t\t\t\t</Stack>\r\n\t\t\t</Paper>\r\n\t\t\t<Box>\r\n\t\t\t\t<Grid container>\r\n\t\t\t\t\t<Grid\r\n\t\t\t\t\t\titem\r\n\t\t\t\t\t\txs={12}\r\n\t\t\t\t\t\tlg={6}\r\n\t\t\t\t\t\tdisplay={\r\n\t\t\t\t\t\t\tleftPanelOpen ? \"none\" : undefined\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<Box\r\n\t\t\t\t\t\t\toverflow=\"auto\"\r\n\t\t\t\t\t\t\theight={`calc(100vh - ${appBarStaticHeight}px)`}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t{slotPanelLeft}\r\n\t\t\t\t\t\t</Box>\r\n\t\t\t\t\t</Grid>\r\n\t\t\t\t\t<Grid\r\n\t\t\t\t\t\titem\r\n\t\t\t\t\t\txs\r\n\t\t\t\t\t\tlg\r\n\t\t\t\t\t\tdisplay={\r\n\t\t\t\t\t\t\tmatchBreakpointXs && !leftPanelOpen\r\n\t\t\t\t\t\t\t\t? \"none\"\r\n\t\t\t\t\t\t\t\t: undefined\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<Box\r\n\t\t\t\t\t\t\toverflow=\"auto\"\r\n\t\t\t\t\t\t\theight={`calc(100vh - ${appBarStaticHeight}px)`}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t{slotPanelRight}\r\n\t\t\t\t\t\t</Box>\r\n\t\t\t\t\t</Grid>\r\n\t\t\t\t</Grid>\r\n\t\t\t</Box>\r\n\t\t</Box>\r\n\t);\r\n};\r\n","/**\r\n * This module provides helper functions for the \"LiveEditor\" component.\r\n */\r\n// ---------------------------------------------\r\n\r\n/**\r\n * The \"generateUniqueLink\" function generates a unique link based the current editor content and the current location href.\r\n */\r\nexport const generateUniqueLink = (\r\n\teditorContent: string,\r\n\tlocationHref: string,\r\n) => {\r\n\tconst url = new URL(locationHref);\r\n\turl.searchParams.set(\"preview\", \"true\");\r\n\turl.searchParams.set(\"content\", editorContent);\r\n\treturn url.href;\r\n};\r\n\r\n/**\r\n * The \"getPreviewState\" function returns a boolean indicating whether the current location href is in preview mode.\r\n */\r\nexport const getPreviewState = (\r\n\tlocationHref: string,\r\n): boolean => {\r\n\tconst url = new URL(locationHref);\r\n\tconst previewParam =\r\n\t\turl.searchParams.get(\"preview\");\r\n\treturn (\r\n\t\tpreviewParam !== null &&\r\n\t\tpreviewParam === \"true\"\r\n\t);\r\n};\r\n","import {\r\n\tFC,\r\n\tFragment,\r\n\tuseEffect,\r\n\tuseState,\r\n} from \"react\";\r\n\r\nimport {\r\n\tPaper,\r\n\tMenuList,\r\n\tListItemText,\r\n\tButtonGroup,\r\n\tPopover,\r\n\tMenuItem,\r\n\tListItemIcon,\r\n\tTheme,\r\n\tuseMediaQuery,\r\n} from \"@mui/material\";\r\nimport {\r\n\tDownloadRounded,\r\n\tSendRounded,\r\n} from \"@mui/icons-material\";\r\nimport { useSnackbar } from \"notistack\";\r\n\r\nimport {\r\n\tlexerGetAllTokens,\r\n\tlexerInit,\r\n\tDiagramNode,\r\n\tparserGetAllNodes,\r\n\tparserInit,\r\n} from \"core\";\r\n\r\nimport { DiagramPreview } from \"App/components/DiagramPreview\";\r\nimport { StyledCodeEditor } from \"App/components/StyledCodeEditor\";\r\nimport { AdaptiveButton } from \"App/components/AdaptiveButton\";\r\n\r\nimport { Layout } from \"./Layout\";\r\nimport { useExportDiagram } from \"./useExportDiagram\";\r\nimport { useEditorContent } from \"./useEditorContent\";\r\nimport { generateUniqueLink } from \"./helper\";\r\n\r\n/**\r\n * The main component of the application.\r\n * It defines the primary interface of the application, as well as the main logic.\r\n *\r\n * The layout is controlled by the \"Layout\" component.\r\n * The \"StyledCodeEditor\" component provides text editor.\r\n * The \"DiagramPreview\" component provides the diagram preview.\r\n */\r\nexport const LiveEditor: FC = () => {\r\n\t// Prepare the snackbar feedback functionality\r\n\tconst { enqueueSnackbar } = useSnackbar();\r\n\t// Prepare the export functionality\r\n\tconst { exportJPEG, exportPNG, exportSVG } =\r\n\t\tuseExportDiagram(\r\n\t\t\t\"structogram-preview-region\",\r\n\t\t);\r\n\t// Prepare the editor content\r\n\tconst { editorContent, setEditorContent } =\r\n\t\tuseEditorContent(\r\n\t\t\twindow.location.href,\r\n\t\t\t\"autosaveContent\",\r\n\t\t);\r\n\tconst matchBreakpointXs = useMediaQuery<Theme>(\r\n\t\t(theme) => theme.breakpoints.down(\"md\"),\r\n\t);\r\n\r\n\t// Stores the parsed nodes which will be sent to the diagram preview to render\r\n\tconst [nodes, setNodes] = useState<\r\n\t\tDiagramNode[]\r\n\t>([]);\r\n\t// Stores the anchor element for the export menu popover\r\n\tconst [\r\n\t\tpopoverExportMenuAnchor,\r\n\t\tsetPopoverExportMenuAnchor,\r\n\t] = useState<HTMLButtonElement | null>(null);\r\n\r\n\t// Fires when the editor content changes\r\n\t// Signals the lexer and parser to re-parse the content\r\n\t// One issue is that the entire abstract syntax tree is re-parsed on every keystroke\r\n\t// This is not ideal, but it is a simple solution for now\r\n\tuseEffect(() => {\r\n\t\tconst tokens = lexerGetAllTokens(\r\n\t\t\tlexerInit(editorContent),\r\n\t\t);\r\n\t\tconst nodes = parserGetAllNodes(\r\n\t\t\tparserInit(tokens),\r\n\t\t);\r\n\t\tsetNodes(nodes);\r\n\t}, [editorContent]);\r\n\r\n\t// Fire when the \"COPY LINK\" button is clicked\r\n\t// The function writes the unique link to the clipboard\r\n\t// The unique link is generated by a helper function\r\n\tconst handleCopyLink = () => {\r\n\t\tnavigator.clipboard.writeText(\r\n\t\t\tgenerateUniqueLink(\r\n\t\t\t\teditorContent,\r\n\t\t\t\twindow.location.href,\r\n\t\t\t),\r\n\t\t);\r\n\t\t// Signals a success message to the user\r\n\t\tenqueueSnackbar(\"Link copied to clipboard\", {\r\n\t\t\tvariant: \"info\",\r\n\t\t});\r\n\t};\r\n\r\n\t// Fires when the \"EXPORT\" button is clicked\r\n\t// The popover is displayed with the export options\r\n\tconst handlePopoverExportMenuOpen = (\r\n\t\tevent: React.MouseEvent<HTMLButtonElement>,\r\n\t) => {\r\n\t\tsetPopoverExportMenuAnchor(\r\n\t\t\tevent.currentTarget,\r\n\t\t);\r\n\t};\r\n\r\n\t// Fires when the export menu popover is closed or dismissed\r\n\tconst handlePopoverExportMenuClose = () => {\r\n\t\tsetPopoverExportMenuAnchor(null);\r\n\t};\r\n\r\n\t// Fires when an export option is selected\r\n\tconst handleExportDiagram = async (\r\n\t\texportCallback: () => Promise<boolean>,\r\n\t) => {\r\n\t\texportCallback().then((success) => {\r\n\t\t\tif (success) {\r\n\t\t\t\tenqueueSnackbar(\"Diagram exported\", {\r\n\t\t\t\t\tvariant: \"info\",\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tenqueueSnackbar(\r\n\t\t\t\t\"Failed to export diagram\",\r\n\t\t\t\t{\r\n\t\t\t\t\tvariant: \"error\",\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t});\r\n\t};\r\n\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<Layout\r\n\t\t\t\tslotAppBar={\r\n\t\t\t\t\t<ButtonGroup variant=\"outlined\">\r\n\t\t\t\t\t\t<AdaptiveButton\r\n\t\t\t\t\t\t\tcollapsed={matchBreakpointXs}\r\n\t\t\t\t\t\t\tstartIcon={<DownloadRounded />}\r\n\t\t\t\t\t\t\tonClick={\r\n\t\t\t\t\t\t\t\thandlePopoverExportMenuOpen\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tEXPORT\r\n\t\t\t\t\t\t</AdaptiveButton>\r\n\t\t\t\t\t\t<AdaptiveButton\r\n\t\t\t\t\t\t\tcollapsed={matchBreakpointXs}\r\n\t\t\t\t\t\t\tendIcon={<SendRounded />}\r\n\t\t\t\t\t\t\tonClick={handleCopyLink}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tSHARE\r\n\t\t\t\t\t\t</AdaptiveButton>\r\n\t\t\t\t\t</ButtonGroup>\r\n\t\t\t\t}\r\n\t\t\t\tslotPanelLeft={\r\n\t\t\t\t\t<StyledCodeEditor\r\n\t\t\t\t\t\tvalue={editorContent}\r\n\t\t\t\t\t\tonValueChange={setEditorContent}\r\n\t\t\t\t\t/>\r\n\t\t\t\t}\r\n\t\t\t\tslotPanelRight={\r\n\t\t\t\t\t<DiagramPreview\r\n\t\t\t\t\t\tnodes={nodes}\r\n\t\t\t\t\t\tid=\"structogram-preview-region\"\r\n\t\t\t\t\t\tboxProps={{\r\n\t\t\t\t\t\t\tpadding: 4,\r\n\t\t\t\t\t\t\tuserSelect: \"none\",\r\n\t\t\t\t\t\t}}\r\n\t\t\t\t\t/>\r\n\t\t\t\t}\r\n\t\t\t/>\r\n\t\t\t<Popover\r\n\t\t\t\tanchorOrigin={{\r\n\t\t\t\t\tvertical: \"bottom\",\r\n\t\t\t\t\thorizontal: \"left\",\r\n\t\t\t\t}}\r\n\t\t\t\ttransformOrigin={{\r\n\t\t\t\t\tvertical: \"top\",\r\n\t\t\t\t\thorizontal: \"left\",\r\n\t\t\t\t}}\r\n\t\t\t\tanchorEl={popoverExportMenuAnchor}\r\n\t\t\t\topen={popoverExportMenuAnchor !== null}\r\n\t\t\t\tonClose={handlePopoverExportMenuClose}\r\n\t\t\t>\r\n\t\t\t\t<Paper\r\n\t\t\t\t\tsx={{\r\n\t\t\t\t\t\tpadding: 1,\r\n\t\t\t\t\t}}\r\n\t\t\t\t>\r\n\t\t\t\t\t<MenuList>\r\n\t\t\t\t\t\t<MenuItem\r\n\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\thandleExportDiagram(exportJPEG)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<ListItemIcon>\r\n\t\t\t\t\t\t\t\t<DownloadRounded fontSize=\"small\" />\r\n\t\t\t\t\t\t\t</ListItemIcon>\r\n\t\t\t\t\t\t\t<ListItemText>\r\n\t\t\t\t\t\t\t\tSave as JPEG\r\n\t\t\t\t\t\t\t</ListItemText>\r\n\t\t\t\t\t\t</MenuItem>\r\n\t\t\t\t\t\t<MenuItem\r\n\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\thandleExportDiagram(exportPNG)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<ListItemIcon>\r\n\t\t\t\t\t\t\t\t<DownloadRounded fontSize=\"small\" />\r\n\t\t\t\t\t\t\t</ListItemIcon>\r\n\t\t\t\t\t\t\t<ListItemText>\r\n\t\t\t\t\t\t\t\tSave as PNG\r\n\t\t\t\t\t\t\t</ListItemText>\r\n\t\t\t\t\t\t</MenuItem>\r\n\t\t\t\t\t\t<MenuItem\r\n\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\thandleExportDiagram(exportSVG)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t<ListItemIcon>\r\n\t\t\t\t\t\t\t\t<DownloadRounded fontSize=\"small\" />\r\n\t\t\t\t\t\t\t</ListItemIcon>\r\n\t\t\t\t\t\t\t<ListItemText>\r\n\t\t\t\t\t\t\t\tSave as SVG\r\n\t\t\t\t\t\t\t</ListItemText>\r\n\t\t\t\t\t\t</MenuItem>\r\n\t\t\t\t\t</MenuList>\r\n\t\t\t\t</Paper>\r\n\t\t\t</Popover>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n","/**\r\n * This module implements a custom hook for exporting diagrams\r\n */\r\n\r\nimport { saveAs } from \"file-saver\";\r\nimport {\r\n\ttoJpeg,\r\n\ttoPng,\r\n\ttoSvg,\r\n} from \"html-to-image\";\r\n\r\n/**\r\n * The \"useExportDiagram\" hook provides functions for exporting diagrams as SVG, PNG, and JPEG files based from an element with a given id.\r\n *\r\n * The process of exporting diagrams is done by converting the HTML element to a blob using functions provided by the \"html-to-image\" library.\r\n * The blob is then saved as a file using the \"file-saver\" library.\r\n */\r\nexport const useExportDiagram = (\r\n\ttargetElementId: string,\r\n) => {\r\n\tconst exportSVG = async () => {\r\n\t\tconst HTMLNode = document.getElementById(\r\n\t\t\ttargetElementId,\r\n\t\t);\r\n\t\tif (HTMLNode === null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn toSvg(HTMLNode).then((blob) => {\r\n\t\t\tif (blob === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tsaveAs(blob, \"structogram\");\r\n\t\t\treturn true;\r\n\t\t});\r\n\t};\r\n\r\n\tconst exportPNG = async () => {\r\n\t\tconst HTMLNode = document.getElementById(\r\n\t\t\ttargetElementId,\r\n\t\t);\r\n\t\tif (HTMLNode === null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn toPng(HTMLNode).then((blob) => {\r\n\t\t\tif (blob === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tsaveAs(blob, \"structogram\");\r\n\t\t\treturn true;\r\n\t\t});\r\n\t};\r\n\r\n\tconst exportJPEG = async () => {\r\n\t\tconst HTMLNode = document.getElementById(\r\n\t\t\ttargetElementId,\r\n\t\t);\r\n\t\tif (HTMLNode === null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn toJpeg(HTMLNode).then((blob) => {\r\n\t\t\tif (blob === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tsaveAs(blob, \"structogram\");\r\n\t\t\treturn true;\r\n\t\t});\r\n\t};\r\n\r\n\treturn {\r\n\t\texportSVG,\r\n\t\texportJPEG,\r\n\t\texportPNG,\r\n\t};\r\n};\r\n","/**\r\n * This module implements a custom hook for controlling editor content\r\n */\r\n// ---------------------------------------------\r\n\r\nimport { useState } from \"react\";\r\n\r\n/**\r\n * The \"useEditorContent\" hook provides functions for controlling the editor content.\r\n * It initializes and manages the state of the editor content and saves it to local storage.\r\n *\r\n * Based on the the given URL, the hook checks if the \"content\" parameter is present.\r\n * If it is, the hook sets the editor content to the value of the \"content\" parameter and sync local storage to the new content.\r\n * If the \"content\" parameter is not present, the hook checks if there is a saved content in local storage.\r\n * If there is, the hook sets the editor content to the saved content.\r\n *\r\n * As such, content from the URL takes precedence over content from local storage.\r\n */\r\nexport const useEditorContent = (\r\n\threfURL: string,\r\n\tlocalStorageKey: string,\r\n) => {\r\n\tconst [editorContent, setEditorContentInner] =\r\n\t\tuseState(() => {\r\n\t\t\tconst url = new URL(hrefURL);\r\n\r\n\t\t\tconst content =\r\n\t\t\t\turl.searchParams.get(\"content\");\r\n\t\t\tif (content !== null) {\r\n\t\t\t\twindow.localStorage.setItem(\r\n\t\t\t\t\tlocalStorageKey,\r\n\t\t\t\t\tcontent,\r\n\t\t\t\t);\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\r\n\t\t\tconst savedContent =\r\n\t\t\t\twindow.localStorage.getItem(\r\n\t\t\t\t\tlocalStorageKey,\r\n\t\t\t\t);\r\n\t\t\tif (savedContent !== null) {\r\n\t\t\t\treturn savedContent;\r\n\t\t\t}\r\n\t\t\treturn \"\";\r\n\t\t});\r\n\r\n\tconst setEditorContent = (content: string) => {\r\n\t\tsetEditorContentInner(content);\r\n\t\twindow.localStorage.setItem(\r\n\t\t\tlocalStorageKey,\r\n\t\t\tcontent,\r\n\t\t);\r\n\t};\r\n\r\n\treturn { editorContent, setEditorContent };\r\n};\r\n","import { Fragment, FC } from \"react\";\r\nimport {\r\n\tCssBaseline,\r\n\tThemeProvider,\r\n\tcreateTheme,\r\n} from \"@mui/material\";\r\n\r\nimport { SnackbarProvider } from \"notistack\";\r\n\r\nimport { LiveEditor } from \"App/components/LiveEditor\";\r\n\r\nconst themeDark = createTheme({\r\n\tpalette: {\r\n\t\tmode: \"dark\",\r\n\t},\r\n});\r\n\r\n/**\r\n * The main application component.\r\n * It resets the CSS and define the \"Theme\" and the \"Snackbar\" provider.\r\n *\r\n * The \"LiveEditor\" component is the main component of the application, and this component is a wrapper for it.\r\n */\r\nexport const App: FC = () => {\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<CssBaseline />\r\n\t\t\t<ThemeProvider theme={themeDark}>\r\n\t\t\t\t<SnackbarProvider\r\n\t\t\t\t\tpreventDuplicate\r\n\t\t\t\t\tautoHideDuration={2000}\r\n\t\t\t\t\tanchorOrigin={{\r\n\t\t\t\t\t\tvertical: \"top\",\r\n\t\t\t\t\t\thorizontal: \"center\",\r\n\t\t\t\t\t}}\r\n\t\t\t\t>\r\n\t\t\t\t\t<LiveEditor />\r\n\t\t\t\t</SnackbarProvider>\r\n\t\t\t</ThemeProvider>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom/client\";\r\n\r\nimport { App } from \"./App\";\r\n\r\nReactDOM.createRoot(\r\n\tdocument.getElementById(\"root\")!,\r\n).render(\r\n\t<React.StrictMode>\r\n\t\t<App />\r\n\t</React.StrictMode>,\r\n);\r\n"],"names":["DiagramTokenKind","DiagramTokenKind2","KEYWORDS","LITERAL_TOKENS","lexerGetNextToken","l","token","kind","text","lineNumber","charNumber","cursorPos","contentLength","content","test","includes","DiagramNodeKind","DiagramNodeKind2","parserInit","tokens","tokenLength","length","parserCollectTokensBetween","p","startToken","stopToken","depth","push","parserSkipWhiteSpace","WHITE_SPACE","buildMissingTokenError","markerToken","at","missingToken","reason","context","caretOffset","buildUnexpectedTokenError","errorToken","expectedToken","markerTokenText","errorTokenText","parserGetNextNode","KEYWORD","node","body","condition","LEFT_PAREN","RIGHT_PAREN","pop","LEFT_CURLY","bodyTokens","RIGHT_CURLY","parserGetAllNodes","parserBuildLoopFirstNode","SEMICOLON","parserBuildLoopLastNode","bodyIf","bodyElse","bodyIfTokens","bodyElseTokens","parserBuildIfElseNode","declaration","nodes","ArrowTopLeftBottomRight","props","sx","jsxRuntimeExports","jsx","SvgIcon","position","width","height","children","xmlns","preserveAspectRatio","fill","viewBox","strokeWidth","x1","y1","x2","y2","stroke","strokeLinecap","ArrowBottomLeftTopRight","DiagramWrapper","borderTop","borderBottom","borderLeft","borderRight","Box","borderStyle","borderLeftWidth","borderTopWidth","borderBottomWidth","borderRightWidth","DiagramComponentText","rest","Typography","padding","fontFamily","wordBreak","fontVariantLigatures","DiagramProcess","bodyText","map","join","trim","DiagramLoopFirst","conditionTokens","conditionText","bodyNode","subnode","index","Diagram","jsxs","paddingLeft","DiagramLoopLast","DiagramIfElse","bodyNodeIf","bodyNodeElse","Grid","container","item","xs","align","display","alignItems","justifyContent","zIndex","backgroundColor","grey","htmlColor","Stack","borderColor","borderRightStyle","DiagramFunc","declarationTokens","declarationText","paddingX","DiagramError","errorText","caretText","repeat","paddingY","ERROR","FUNCTION","LOOP_FIRST","LOOP_LAST","IF_ELSE","PROCESS","Fragment","DiagramPreview","id","boxProps","component","fontStyle","maxWidth","StyledCodeEditor","value","onValueChange","ReactCodeMirror","onChange","theme","extensions","EditorView","lineWrapping","AdaptiveButton","collapsed","Tooltip","title","Button","startIcon","endIcon","Layout","slotAppBar","slotPanelLeft","slotPanelRight","appBarRef","useRef","appBarStaticHeight","setAppBarStaticHeight","useState","leftPanelOpen","setLeftPanelOpen","locationHref","previewParam","URL","searchParams","get","getPreviewState","window","location","href","matchBreakpointXs","useMediaQuery","breakpoints","down","useEffect","current","getBoundingClientRect","Paper","ref","square","elevation","direction","ButtonGroup","variant","onClick","prev","target","LaunchRounded","lg","overflow","LiveEditor","enqueueSnackbar","useSnackbar","exportJPEG","exportPNG","exportSVG","targetElementId","async","HTMLNode","document","getElementById","toSvg","then","blob","toJpeg","toPng","editorContent","setEditorContent","hrefURL","localStorageKey","setEditorContentInner","localStorage","setItem","savedContent","getItem","useEditorContent","setNodes","popoverExportMenuAnchor","setPopoverExportMenuAnchor","lexerGetAllTokens","preprocessedContent","contentPos","removeComments","normalize","lexerInit","handleExportDiagram","exportCallback","success","DownloadRounded","event","currentTarget","SendRounded","navigator","clipboard","writeText","url","set","generateUniqueLink","userSelect","Popover","anchorOrigin","vertical","horizontal","transformOrigin","anchorEl","open","onClose","MenuList","MenuItem","ListItemIcon","fontSize","ListItemText","themeDark","createTheme","palette","mode","App","CssBaseline","ThemeProvider","SnackbarProvider","preventDuplicate","autoHideDuration","ReactDOM","createRoot","render","React","StrictMode"],"mappings":"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"}